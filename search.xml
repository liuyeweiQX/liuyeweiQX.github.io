<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CompletableFuture异步任务</title>
    <url>/2020/12/16/CompletableFuture%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>所谓异步调用其实就是实现一个可无需等待被调用函数的返回值而让操作继续运行的方法。<strong>在 Java 语言中，简单的讲就是另启一个线程来完成调用中的部分计算，使调用继续运行或返回，而不需要等待计算结果。但调用者仍需要取线程的计算结果</strong>。</p>
<h4 id="Java实现多线程的三种方式"><a href="#Java实现多线程的三种方式" class="headerlink" title="Java实现多线程的三种方式"></a>Java实现多线程的三种方式</h4><ul>
<li>继承Thread类<br>run() 方法 和 start() 方法：<br>run() 方法：普通的成员方法<br>start() 方法：负责启动一个新的线程，并调用 run() 方法</li>
</ul>
<p><strong>因此启动线程，需要使用 start() 方法</strong>  </p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/12/16/CompletableFuture%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/content1.png" class title="content1">   
<ul>
<li>实现 Runnable 接口</li>
</ul>
<p><strong>实际上 Thread 类也是实现了 Runnable 接口：</strong><br>class Thread implements Runnable {<br><strong>启动 Runnable 实例时，需要放在 Thread 中，然后调用 start() 方法</strong>     </p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/12/16/CompletableFuture%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/content2.png" class title="content2">  

<ul>
<li>实现 Callable 接口<br>Java 5 开始提供<br>可以返回结果（通过 Future），也可以抛出异常<br>需要实现的是 call() 方法</li>
</ul>
<p><strong>以上两点也是 Callable 接口 与 Runnable 接口的区别</strong></p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/12/16/CompletableFuture%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/content3.png" class title="content3">     

<h4 id="Java-FutureTask可异步执行的任务"><a href="#Java-FutureTask可异步执行的任务" class="headerlink" title="Java FutureTask可异步执行的任务"></a>Java FutureTask可异步执行的任务</h4><p>FutureTask 是 Future 接口的一个实现类。<br>使用方式：</p>
<ul>
<li>构造一个 Callable 接口的实例</li>
<li>构造一个 FutureTask 的实例，封装 Callable 接口的实例</li>
<li>通过线程池 ExecutorService 来运行 FutureTask 的实例</li>
<li>通过 get() 方法来获得结果</li>
</ul>
<p><strong>可以看出，FutureTask 与使用 Callable &amp; Future 的目的差不多，因此 FutureTask 实际不常使用，直接使用 Callable &amp; Future 就可以了</strong>。   </p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/12/16/CompletableFuture%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/content4.png" class title="content4">  

<p>JDK5 新增了 Future 接口，用于描述一个异步计算的结果。虽然 Future 以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，<strong>只能通过阻塞或者轮询的方式得到任务的结果</strong>。 例如：</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/12/16/CompletableFuture%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/content5.png" class title="content5">

<p>阻塞的方式显然和我们的异步编程的初衷相违背，轮询的方式又会耗费无谓的 CPU 资源，而且也不能及时地得到计算结果，<strong>为什么不能用观察者设计模式呢？即当计算结果完成及时通知监听者。（例如通过回调的方式）</strong> </p>
<h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><p>Java 8 中, 新增加了一个包含 50 个方法左右的类 CompletableFuture，它提供了非常强大的 Future 的扩展功能，可以帮助我们简化异步编程的复杂性，并且提供了函数式编程的能力，可以通过回调的方式处理计算结果，也提供了转换和组合 CompletableFuture 的方法。</p>
<p>对于阻塞或者轮询方式，依然可以通过 CompletableFuture 类的 CompletionStage 和 Future 接口方式支持。</p>
<p>CompletableFuture 类声明了 CompletionStage 接口，CompletionStage 接口实际上提供了同步或异步运行计算的舞台，所以我们可以通过实现多个 CompletionStage 命令，并且将这些命令串联在一起的方式实现多个命令之间的触发。</p>
<p>我们可以通过 CompletableFuture.supplyAsync(this::sendMsg); 这么一行代码创建一个简单的异步计算。在这行代码中，supplyAsync 支持异步地执行我们指定的方法，这个例子中的异步执行方法是 sendMsg。当然，我们也可以使用 Executor 执行异步程序，默认是 ForkJoinPool.commonPool()。<br>我们也可以在异步计算结束之后指定回调函数，例如 CompletableFuture.supplyAsync(this::sendMsg) .thenAccept(this::notify);<br>这行代码中的 thenAccept 被用于增加回调函数，在我们的示例中 notify 就成了异步计算的消费者，它会处理计算结果。   </p>
<h3 id="CompletionStage-接口"><a href="#CompletionStage-接口" class="headerlink" title="CompletionStage 接口"></a>CompletionStage<T> 接口</T></h3><p>一个可能执行的异步计算的某个阶段，在另一个CompletionStage完成时执行一个操作或计算一个值。<br>一个阶段完成后，其计算结束。但是，该计算阶段可能会触发下一个计算阶段。<br>最简单的例子<br>CompletableFuture 实际上也实现了 Future 接口： </p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/12/16/CompletableFuture%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/content6.png" class title="content6">      

<p>所以我们也可以利用 CompletableFuture 来实现基本的 Future 功能，例如：</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/12/16/CompletableFuture%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/content7.png" class title="content7"> 

<p>此时此刻主线程 future.get() 将得到字符串的结果 I have completed，同时完成回调以后将会立即生效。注意 complete() 方法只能调用一次，后续调用将被忽略。<br>注意：get() 方法可能会抛出异常 InterruptedException 和 ExecutionException。<br>如果我们已经知道了异步任务的结果，我们也可以直接创建一个已完成的 future，如下：</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/12/16/CompletableFuture%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/content8.png" class title="content8"> 

<p>如果在异步执行过程中，我们觉得执行会超时或者会出现问题，我们也可以通过 cancle() 方法取消，此时调用 get() 方法时会产生异常 java.util.concurrent.CancellationException，代码如下：</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/12/16/CompletableFuture%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/content9.png" class title="content9"> 

<h3 id="使用工厂方法创建-CompletableFuture"><a href="#使用工厂方法创建-CompletableFuture" class="headerlink" title="使用工厂方法创建 CompletableFuture"></a>使用工厂方法创建 CompletableFuture</h3><p>在上述的代码中，我们手动地创建 CompletableFuture，并且手动的创建一个线程（或者利用线程池）来启动异步任务，这样似乎有些复杂。</p>
<p>其实我们可以利用 CompletableFuture 的工厂方法，传入 Supplier 或者 Runnable 的实现类，直接得到一个 CompletableFuture 的实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier)</span><br><span class="line">public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)</span><br><span class="line">public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable)</span><br><span class="line">public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable, Executor executor)</span><br></pre></td></tr></table></figure>
<p>第一个和第三个方法，没有 Executor 参数，将会使用 ForkJoinPool.commonPool() (全局的，在 JDK8 中介绍的通用池），这适用于 CompletableFuture 类中的大多数的方法。</p>
<ul>
<li>Runnable 接口方法 public abstract void run(); 没有返回值</li>
<li>Supplier 接口方法 T get(); 有返回值。<strong>如果你需要处理异步操作并返回结果，使用前两种 Supplier<U> 方法</U></strong><br>使用 Lambda 表达式来传入 Supplier 或者 Runnable 的实现类。 <img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/12/16/CompletableFuture%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/content10.png" class title="content10">  </li>
</ul>
<h3 id="转换和作用于异步任务的结果-thenApply"><a href="#转换和作用于异步任务的结果-thenApply" class="headerlink" title="转换和作用于异步任务的结果 (thenApply)"></a>转换和作用于异步任务的结果 (thenApply)</h3><p>我们可以叠加功能，把多个 future 组合在一起等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenApply(Function&lt;? super T,? extends U&gt; fn)</span><br></pre></td></tr></table></figure>
<p>该方法的作用是在该计算阶段正常完成后，将该计算阶段的结果作为参数传递给参数 fn 值的函数Function，并会返回一个新的 CompletionStage</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenApplyAsync(Function&lt;? super T,? extends U&gt; fn)</span><br></pre></td></tr></table></figure>
<p>该方法和上面的方法 thenApply 功能类似，不同的是对该计算阶段的结果进行计算的函数 fn 的执行时异步的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenApplyAsync(Function&lt;? super T,? extends U&gt; fn, Executor executor)</span><br></pre></td></tr></table></figure>
<p>该方法和上面的方法 thenApplyAsync 功能类似，不同的是对该计算阶段的结果进行计算的函数 fn 的执行时异步的， 并且是在调用者提供的线程池中执行的。<br>Function 接口方法 R apply(T t); 包含一个参数和一个返回值<br>一个示例代码如下：</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/12/16/CompletableFuture%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/content11.png" class title="content11"> 

<h3 id="运行完成的异步任务的结果-thenAccept-thenRun"><a href="#运行完成的异步任务的结果-thenAccept-thenRun" class="headerlink" title="运行完成的异步任务的结果 (thenAccept/thenRun)"></a>运行完成的异步任务的结果 (thenAccept/thenRun)</h3><p>在 future 的管道里有两种典型的“最终”阶段方法。他们在你使用 future 的值的时候做好准备，当 thenAccept() 提供最终的值时，thenRun 执行 Runnable。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public CompletableFuture&lt;Void&gt; thenAccept(Consumer&lt;? super T&gt; action)</span><br><span class="line">public CompletableFuture&lt;Void&gt; thenAcceptAsync(Consumer&lt;? super T&gt; action)</span><br><span class="line">public CompletableFuture&lt;Void&gt; thenAcceptAsync(Consumer&lt;? super T&gt; action, Executor executor)</span><br><span class="line">public CompletableFuture&lt;Void&gt; thenRun(Runnable action)</span><br><span class="line">public CompletableFuture&lt;Void&gt; thenRunAsync(Runnable action)</span><br><span class="line">public CompletableFuture&lt;Void&gt; thenRunAsync(Runnable action, Executor executor)</span><br></pre></td></tr></table></figure>
<p>Consumer 接口方法 void accept(T t); 包含一个参数，但是没有返回值<br>一个示例代码如下：</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/12/16/CompletableFuture%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/content12.png" class title="content12"> 

<h3 id="结合两个-CompletableFuture"><a href="#结合两个-CompletableFuture" class="headerlink" title="结合两个 CompletableFuture"></a>结合两个 CompletableFuture</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenCompose(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span><br><span class="line">//传入前一个 CompletableFuture 的返回值，返回另外一个 CompletableFuture 实例</span><br><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenComposeAsync(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span><br><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenComposeAsync(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor)</span><br><span class="line">public &lt;U,V&gt; CompletableFuture&lt;V&gt; thenCombine(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn)</span><br><span class="line">public &lt;U,V&gt; CompletableFuture&lt;V&gt; thenCombineAsync(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn)</span><br><span class="line">public &lt;U,V&gt; CompletableFuture&lt;V&gt; thenCombineAsync(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn, Executor executor)</span><br></pre></td></tr></table></figure>
<p>一个示例代码如下：</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/12/16/CompletableFuture%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/content13.png" class title="content13"> 

<p>上述功能也可以通过 thenCombine() 方法实现，传入一个 BiFunction 接口的实例（以 Lambda 形式） 例如： </p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/12/16/CompletableFuture%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/content14.png" class title="content14"> 

<h3 id="并行执行多个异步任务"><a href="#并行执行多个异步任务" class="headerlink" title="并行执行多个异步任务"></a>并行执行多个异步任务</h3><p>有时候我们可能需要等待所有的异步任务都执行完毕，然后组合他们的结果。我们可以使用 allOf() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static CompletableFuture&lt;Void&gt; allOf(CompletableFuture&lt;?&gt;... cfs)</span><br></pre></td></tr></table></figure>
<p>一个示例代码如下：</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/12/16/CompletableFuture%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/content15.png" class title="content15">

<p>有时候我们可能<strong>不需要</strong>等待所有的异步任务都执行完毕，只要任何一个任务完成就返回结果。我们可以使用 anyOf() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static CompletableFuture&lt;Object&gt; anyOf(CompletableFuture&lt;?&gt;... cfs)</span><br></pre></td></tr></table></figure>
<p>一个示例代码如下：</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/12/16/CompletableFuture%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/content16.png" class title="content16">
<h3 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h3><p>我们可以在 handle() 方法里处理异常：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; handle(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn) </span><br></pre></td></tr></table></figure>
<p>第一个参数为 CompletableFuture 返回的结果<br>第二个参数为抛出的异常<br>一个示例代码如下：  </p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/12/16/CompletableFuture%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/content17.png" class title="content17">                           ]]></content>
      <categories>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title>Git基础学习</title>
    <url>/2021/04/14/Git%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p><strong>版本控制</strong>（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前版本的软件工程技术。</p>
<ol>
<li>实现跨区域多人协同开发</li>
<li>追踪和记载一个或者多个文件的历史记录</li>
<li>组织和保护你的源代码和文档</li>
<li>统计工作量</li>
<li>并行开发、提高开发效率</li>
<li>跟踪记录整个软件的开发过程</li>
<li>减轻开发人员的负担，节约时间，同时降低人为错误</li>
</ol>
<p>主流版本控制工具：Git、SVN、CVS、VSS、TFS、Visual Studio Online</p>
<h3 id="Git和SVN的区别"><a href="#Git和SVN的区别" class="headerlink" title="Git和SVN的区别"></a>Git和SVN的区别</h3><ol>
<li><p>本地版本控制<br>记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人使用</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/04/14/Git%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/content1.png" class title="content1"></li>
<li><p>集中版本控制（代表工具：SVN）<br>所有的版本数据都存在服务器上，用户本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/04/14/Git%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/content2.png" class title="content2"></li>
<li><p>分布式版本控制<br>每个人都拥有全部的代码，有安全隐患。<br>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。<br>不会因为服务器损坏或者网络问题，造成不能工作的情况！</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/04/14/Git%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/content3.png" class title="content3"></li>
</ol>
<p><strong>Git与SVN最主要区别</strong><br>SVN是集中式版本控制系统、版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。<br>Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件。<br>Git是目前世界上最先进的分布式版本控制系统。</p>
<h3 id="Git环境配置"><a href="#Git环境配置" class="headerlink" title="Git环境配置"></a>Git环境配置</h3><p>官网下载：<a href="https://git-scm.com/%EF%BC%8C">https://git-scm.com/，</a>  下载git对应操作系统的版本。<br>官网下载太慢，可以使用淘宝镜像下载：<a href="http://npm.taobao.org/mirrors/git-for-windows/">http://npm.taobao.org/mirrors/git-for-windows/</a><br>安装则一直点击下一步<br>卸载则先清理环境变量配置，再卸载</p>
<ul>
<li>Git Bash：Unix与Linux的风格的命令行，使用最多，推荐最多</li>
<li>Git CMD：Windows风格的命令行</li>
<li>Git GUI：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令</li>
</ul>
<p>基本Linux命令学习：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd：改变目录</span><br><span class="line">cd .. ：回退到上一个目录，直接cd进入默认目录</span><br><span class="line">pwd：显示当前所在的目录路径</span><br><span class="line">ls(ll)：都是列出当前目录中的所有文件，只不过ll列出的内容更为详细</span><br><span class="line">touch：新建一个文件 如touch index.js 就会在当前目录下新建一个index.js文件</span><br><span class="line">rm：删除一个文件，rm index.js 就会把index.js文件删除</span><br><span class="line">mkdir：新建一个文件夹</span><br><span class="line">rm -r：删除一个文件夹，rm -r src删除src文件夹</span><br><span class="line">mv：移动文件，mv index.html src 将index.html文件移动到src目录下</span><br><span class="line">reset：重新初始化终端/清屏</span><br><span class="line">clear：清屏</span><br><span class="line">history：查看命令历史</span><br><span class="line">help：帮助</span><br><span class="line">exit：退出</span><br><span class="line">#表示注释</span><br></pre></td></tr></table></figure>

<p>查看配置：git config -l<br>查看全局配置：git config –global –list（这个事先必须自己先配置好）</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/04/14/Git%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/content4.png" class title="content4">
<p>git config –global user.name “liuyeweiQX” #名称<br>git config –global user.email <a href="mailto:&#x37;&#x36;&#x39;&#52;&#57;&#57;&#49;&#50;&#64;&#113;&#x71;&#46;&#99;&#111;&#x6d;">&#x37;&#x36;&#x39;&#52;&#57;&#57;&#49;&#50;&#64;&#113;&#x71;&#46;&#99;&#111;&#x6d;</a> #邮箱</p>
<h3 id="Git基本理论"><a href="#Git基本理论" class="headerlink" title="Git基本理论"></a>Git基本理论</h3><p>Git本地有三个工作区域：工作目录（Working Directory）、暂存区（Stage/Index）、资源库（Repository或Git Directory）。如果在加上远程的git仓库（Remote Directory）就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/04/14/Git%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/content5.png" class title="content5">

<ul>
<li>WorkSpace：工作区，就是平时存放项目代码地方</li>
<li>Index/Stage：暂存区，用于临时存放你的改动，事实上他只是一个文件，保存即将提交到文件列表信息</li>
<li>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li>
<li>Remote：远程仓库，托管代码的服务器，可以简单的认为是项目组中的一台电脑用于远程数据交换</li>
</ul>
<h3 id="Git项目搭建"><a href="#Git项目搭建" class="headerlink" title="Git项目搭建"></a>Git项目搭建</h3><p>git init：本地项目创建，创建后可以看到项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面<br>git clone + 远程目录：克隆远程仓库，</p>
<h3 id="Git文件操作"><a href="#Git文件操作" class="headerlink" title="Git文件操作"></a>Git文件操作</h3><p>文件4种状态：</p>
<ul>
<li>Untracked：未跟踪，此文件在文件夹中，但并没有加入到git库，不参与版本控制，通过git add状态变为Staged</li>
<li>Unmodify：文件已经入库，未修改，即版本库中的文件快照内容与文件夹中完全一致，这种类型的文件有两种去处，如果它被修改变为Modified，如果使用git rm移出版本库，则成为Untracked文件</li>
<li>Modified：文件已修改，仅仅是修改，并没有进行其他的操作，这个文件也有两个去处，通过git add可进入暂存staged状态，使用git checked则丢弃修改过，返回unmodify状态，这个git checkout即从库中取出文件，覆盖当前修改</li>
<li>Staged：暂存状态，执行git commit则将修改同步到库中，这时库中的文件和本地文件又变为一致，文件为Unmodify状态，执行git reset HEAD filename取消暂存，文件状态为Modified</li>
</ul>
<p>查看文件状态：git status /git status [filename]<br>添加所有文件到暂存区：git add .<br>提交暂存区的所哟文件到本地仓库：git commit -m</p>
<p><strong>忽略文件</strong>：<br>如果希望某些文件不纳入版本控制，在目录下建立“.gitignore”，此文件有如下规则：<br>#为注释<br><em>.txt    #忽略所有.txt结尾的文件<br>!lib.txt #但lib.txt除外<br>/temp #仅忽略项目根目录下的TODO文件，不包括其它目录temp<br>build/ #忽略build/目录下的所有文件<br>doc/</em>.txt #会忽略 doc/notes.txt 但不包括doc/server/arch.txt</p>
<h3 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h3><p>列出所有本地分支：git branch<br>列出所有远程分支：git branch -r<br>新建分支，但依然停留在当前分支：git branch [branch-name]<br>新建分支，并切换到该分支：git checkout -b [branch]<br>合并指定分支到当前分支：git merge [branch]<br>删除分支：git branch -d [branch-name]<br>删除远程分支：<br>git push origin –delete [branch-name]<br>git branch -dr [remote/branch]</p>
<h3 id="Git项目到github上"><a href="#Git项目到github上" class="headerlink" title="Git项目到github上"></a>Git项目到github上</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin [url]</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Gulp压缩和PWA</title>
    <url>/2020/09/08/Gulp%E5%8E%8B%E7%BC%A9%E5%92%8CPWA/</url>
    <content><![CDATA[<h3 id="Gulp压缩"><a href="#Gulp压缩" class="headerlink" title="Gulp压缩"></a>Gulp压缩</h3><p>Gulp是一款自动化构建的工具</p>
<h4 id="安装Gulp"><a href="#安装Gulp" class="headerlink" title="安装Gulp"></a>安装Gulp</h4><p>npm install –global gulp-cli<br>安装过程中若报权限错误，则执行sudo npm install –global gulp-cli命令</p>
<h4 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h4><ul>
<li>HTML压缩插件：<br>npm install gulp-htmlclean –save-dev<br>npm install –save gulp-htmlmin</li>
<li>CSS压缩插件：<br>npm install gulp-clean-css –save-dev</li>
<li>JS压缩插件：（二选一）<br>terser 是 ES6+ 的 JavaScript 解析器<br>gulp-babel 是一个 JavaScript 转换编译器，可以把 ES6 转换成 ES5<ul>
<li>npm install –save-dev gulp-uglify  ;  npm install terser</li>
<li>npm install –save-dev gulp-uglify  ;  npm install –save-dev gulp-babel @babel/core @babel/preset-env</li>
</ul>
</li>
<li>图片压缩插件：<br>npm install –save-dev gulp-imagemin</li>
</ul>
<h4 id="创建gulpfile-js文件"><a href="#创建gulpfile-js文件" class="headerlink" title="创建gulpfile.js文件"></a>创建gulpfile.js文件</h4><p>在 Hexo 的根目录，创建 gulpfile.js 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const gulp = require(&quot;gulp&quot;);</span><br><span class="line">const workbox = require(&quot;workbox-build&quot;);</span><br><span class="line">const cleanCSS = require(&#x27;gulp-clean-css&#x27;);</span><br><span class="line">const htmlmin = require(&#x27;gulp-htmlmin&#x27;);</span><br><span class="line">const htmlclean = require(&#x27;gulp-htmlclean&#x27;);</span><br><span class="line">const imagemin = require(&#x27;gulp-imagemin&#x27;);</span><br><span class="line">// tester (如果使用tester,把下面4行前面的//去掉)</span><br><span class="line">// const uglifyjs = require(&#x27;terser&#x27;);</span><br><span class="line">// const composer = require(&#x27;gulp-uglify/composer&#x27;);</span><br><span class="line">// const pump = require(&#x27;pump&#x27;);</span><br><span class="line">// const minify = composer(uglifyjs, console);</span><br><span class="line"></span><br><span class="line">// babel (如果不是使用bebel,把下面兩行註釋掉)</span><br><span class="line">const uglify = require(&#x27;gulp-uglify&#x27;)</span><br><span class="line">const babel = require(&#x27;gulp-babel&#x27;)</span><br><span class="line"></span><br><span class="line">// minify js - babel（ 如果不是使用bebel,把下面註釋掉）</span><br><span class="line">gulp.task(&#x27;compress&#x27;, () =&gt;</span><br><span class="line">    gulp.src([&#x27;./public/**/*.js&#x27;, &#x27;!./public/**/*.min.js&#x27;])</span><br><span class="line">        .pipe(babel(&#123;</span><br><span class="line">            presets: [&#x27;@babel/preset-env&#x27;]</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(uglify().on(&#x27;error&#x27;, function (e) &#123;</span><br><span class="line">            console.log(e)</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(&#x27;./public&#x27;))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// minify js - tester (如果使用tester,把下面前面的//去掉)</span><br><span class="line">// gulp.task(&#x27;compress&#x27;, function (cb) &#123;</span><br><span class="line">//   const options = &#123;&#125;;</span><br><span class="line">//   pump([</span><br><span class="line">//     gulp.src([&#x27;./public/**/*.js&#x27;, &#x27;!./public/**/*.min.js&#x27;]),</span><br><span class="line">//     minify(options),</span><br><span class="line">//     gulp.dest(&#x27;./public&#x27;)</span><br><span class="line">//   ],</span><br><span class="line">//   cb</span><br><span class="line">//   );</span><br><span class="line">// &#125;);</span><br><span class="line"></span><br><span class="line">// css</span><br><span class="line">gulp.task(&#x27;minify-css&#x27;, () =&gt; &#123;</span><br><span class="line">    return gulp.src(&#x27;./public/**/*.css&#x27;)</span><br><span class="line">        .pipe(cleanCSS(&#123;</span><br><span class="line">            compatibility: &#x27;ie11&#x27;</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(&#x27;./public&#x27;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 壓縮 public 目錄內 html</span><br><span class="line">gulp.task(&#x27;minify-html&#x27;, () =&gt; &#123;</span><br><span class="line">    return gulp.src(&#x27;./public/**/*.html&#x27;)</span><br><span class="line">        .pipe(htmlclean())</span><br><span class="line">        .pipe(htmlmin(&#123;</span><br><span class="line">            removeComments: true, // 清除 HTML 註釋</span><br><span class="line">            collapseWhitespace: true, // 壓縮 HTML</span><br><span class="line">            collapseBooleanAttributes: true, // 省略布爾屬性的值 &lt;input checked=&quot;true&quot;/&gt; ==&gt; &lt;input /&gt;</span><br><span class="line">            removeEmptyAttributes: true, // 刪除所有空格作屬性值 &lt;input id=&quot;&quot; /&gt; ==&gt; &lt;input /&gt;</span><br><span class="line">            removeScriptTypeAttributes: true, // 刪除 &lt;script&gt; 的 type=&quot;text/javascript&quot;</span><br><span class="line">            removeStyleLinkTypeAttributes: true, // 刪除 &lt;style&gt; 和 &lt;link&gt; 的 type=&quot;text/css&quot;</span><br><span class="line">            minifyJS: true, // 壓縮頁面 JS</span><br><span class="line">            minifyCSS: true, // 壓縮頁面 CSS</span><br><span class="line">            minifyURLs: true</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(&#x27;./public&#x27;))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 压缩 public/uploads 目录内图片</span><br><span class="line">gulp.task(&#x27;minify-images&#x27;, async () =&gt; &#123;</span><br><span class="line">    gulp.src(&#x27;./public/img/**/*.*&#x27;)</span><br><span class="line">        .pipe(imagemin(&#123;</span><br><span class="line">            optimizationLevel: 5, //类型：Number  预设：3  取值範围：0-7（优化等级）</span><br><span class="line">            progressive: true, //类型：Boolean 预设：false 无失真压缩jpg图片</span><br><span class="line">            interlaced: false, //类型：Boolean 预设：false 隔行扫描gif进行渲染</span><br><span class="line">            multipass: false, //类型：Boolean 预设：false 多次优化svg直到完全优化</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(&#x27;./public/img&#x27;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(&#x27;generate-service-worker&#x27;, () =&gt; &#123;</span><br><span class="line">    return workbox.injectManifest(&#123;</span><br><span class="line">        swSrc: &#x27;./sw-template.js&#x27;,</span><br><span class="line">        swDest: &#x27;./public/sw.js&#x27;,</span><br><span class="line">        globDirectory: &#x27;./public&#x27;,</span><br><span class="line">        globPatterns: [</span><br><span class="line">            &quot;**/*.&#123;html,css,js,json,woff2&#125;&quot;</span><br><span class="line">        ],</span><br><span class="line">        modifyURLPrefix: &#123;</span><br><span class="line">            &quot;&quot;: &quot;./&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 執行 gulp 命令時執行的任務</span><br><span class="line">gulp.task(&quot;default&quot;, gulp.series(&quot;generate-service-worker&quot;, gulp.parallel(</span><br><span class="line">    &#x27;compress&#x27;,&#x27;minify-html&#x27;, &#x27;minify-css&#x27;, &#x27;minify-images&#x27;</span><br><span class="line">)));</span><br></pre></td></tr></table></figure>
<p>注意： 如果有使用到 Butterfly 主题提供的 mermaid 标签，那需要把 52 行.pipe(htmlclean()) 注释掉，同时，把 55 行的 collapseWhitespace: true, 改为 false</p>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>在hexo g之后运行gulp</p>
<h3 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h3><p>渐进式网络应用程式（英语：Progressive Web Apps，简称：PWA）是一种普通网页或网站架构起来的网络应用程式，但它可以以传统应用程式或原生移动应用程式形式展示给用户。这种应用程式形态视图将目前最为现代化的浏览器提供的功能与行动装置的体验优势相结合。</p>
<p>当你的网站实现了 PWA，那就代表了:</p>
<ul>
<li>用户可以添加你的博客到电脑╱手机的桌面，以原生应用般的方式浏览你的博客</li>
<li>用户可以更快速地浏览你的博客</li>
<li>用户可以离线浏览你的博客</li>
</ul>
<p>使用 Service Worker。我们使用 Workbox 这个工具生成 sw.js 以快速实现 Service Worker ，并实现页面的预缓存和页面更新后的提醒功能。</p>
<h4 id="开启设置和配置manifest-json"><a href="#开启设置和配置manifest-json" class="headerlink" title="开启设置和配置manifest.json"></a>开启设置和配置manifest.json</h4><p>主题配置文件中开启pwa选项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwa:</span><br><span class="line">  enable: true</span><br><span class="line">  manifest: /img/pwa/manifest.json</span><br><span class="line">  apple_touch_icon: /img/pwa/apple-touch-icon.png</span><br><span class="line">  favicon_32_32: /img/pwa/32.png</span><br><span class="line">  favicon_16_16: /img/pwa/16.png</span><br><span class="line">  mask_icon: /img/pwa/safari-pinned-tab.svg</span><br></pre></td></tr></table></figure>
<h4 id="在主题的source-目录中创建-manifest-json-文件。"><a href="#在主题的source-目录中创建-manifest-json-文件。" class="headerlink" title="在主题的source 目录中创建 manifest.json 文件。"></a>在主题的source 目录中创建 manifest.json 文件。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;string&quot;, //应用全称</span><br><span class="line">    &quot;short_name&quot;: &quot;Junzhou&quot;, //应用简称</span><br><span class="line">    &quot;theme_color&quot;: &quot;#49b1f5&quot;, //匹配浏览器的地址栏颜色</span><br><span class="line">    &quot;background_color&quot;: &quot;#49b1f5&quot;,//加载应用时的背景色</span><br><span class="line">    &quot;display&quot;: &quot;standalone&quot;,//首选显示模式 其他选项有：fullscreen,minimal-ui,browser</span><br><span class="line">    &quot;scope&quot;: &quot;/&quot;,</span><br><span class="line">    &quot;start_url&quot;: &quot;/&quot;,</span><br><span class="line">    &quot;icons&quot;: [ //该数组指定icons图标参数，用来时适配不同设备（需为png，至少包含一个192px*192px的图标）</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;src&quot;: &quot;images/pwaicons/36.png&quot;, //图标文件的目录，需在source/目录下自行创建。</span><br><span class="line">          &quot;sizes&quot;: &quot;36x36&quot;,</span><br><span class="line">          &quot;type&quot;: &quot;image/png&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;src&quot;: &quot;images/pwaicons/48.png&quot;,</span><br><span class="line">          &quot;sizes&quot;: &quot;48x48&quot;,</span><br><span class="line">          &quot;type&quot;: &quot;image/png&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;src&quot;: &quot;images/pwaicons/72.png&quot;,</span><br><span class="line">          &quot;sizes&quot;: &quot;72x72&quot;,</span><br><span class="line">          &quot;type&quot;: &quot;image/png&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;src&quot;: &quot;images/pwaicons/96.png&quot;,</span><br><span class="line">          &quot;sizes&quot;: &quot;96x96&quot;,</span><br><span class="line">          &quot;type&quot;: &quot;image/png&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;src&quot;: &quot;images/pwaicons/144.png&quot;,</span><br><span class="line">          &quot;sizes&quot;: &quot;144x144&quot;,</span><br><span class="line">          &quot;type&quot;: &quot;image/png&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;src&quot;: &quot;images/pwaicons/192.png&quot;,</span><br><span class="line">          &quot;sizes&quot;: &quot;192x192&quot;,</span><br><span class="line">          &quot;type&quot;: &quot;image/png&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;src&quot;: &quot;images/pwaicons/512.png&quot;,</span><br><span class="line">            &quot;sizes&quot;: &quot;512x512&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;image/png&quot;</span><br><span class="line">          &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;splash_pages&quot;: null //配置自定义启动动画。</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="安装插件："><a href="#安装插件：" class="headerlink" title="安装插件："></a>安装插件：</h4><p>npm install workbox-build gulp –save-dev</p>
<h4 id="创建gulpfile-js文件（见上文）"><a href="#创建gulpfile-js文件（见上文）" class="headerlink" title="创建gulpfile.js文件（见上文）"></a>创建gulpfile.js文件（见上文）</h4><h4 id="在-Hexo-的根目录，创建一个-sw-template-js-文件"><a href="#在-Hexo-的根目录，创建一个-sw-template-js-文件" class="headerlink" title="在 Hexo 的根目录，创建一个 sw-template.js 文件"></a>在 Hexo 的根目录，创建一个 sw-template.js 文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const workboxVersion = &#x27;5.1.3&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">importScripts(`https://storage.googleapis.com/workbox-cdn/releases/$&#123;workboxVersion&#125;/workbox-sw.js`);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">workbox.core.setCacheNameDetails(&#123;</span><br><span class="line">    prefix: &quot;your name&quot;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">workbox.core.skipWaiting();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">workbox.core.clientsClaim();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">workbox.precaching.precacheAndRoute(self.__WB_MANIFEST,&#123;</span><br><span class="line">    directoryIndex: null</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">workbox.precaching.cleanupOutdatedCaches();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Images</span><br><span class="line">workbox.routing.registerRoute(</span><br><span class="line">    /\.(?:png|jpg|jpeg|gif|bmp|webp|svg|ico)$/,</span><br><span class="line">    new workbox.strategies.CacheFirst(&#123;</span><br><span class="line">        cacheName: &quot;images&quot;,</span><br><span class="line">        plugins: [</span><br><span class="line">            new workbox.expiration.ExpirationPlugin(&#123;</span><br><span class="line">                maxEntries: 1000,</span><br><span class="line">                maxAgeSeconds: 60 * 60 * 24 * 30</span><br><span class="line">            &#125;),</span><br><span class="line">            new workbox.cacheableResponse.CacheableResponsePlugin(&#123;</span><br><span class="line">                statuses: [0, 200]</span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Fonts</span><br><span class="line">workbox.routing.registerRoute(</span><br><span class="line">    /\.(?:eot|ttf|woff|woff2)$/,</span><br><span class="line">    new workbox.strategies.CacheFirst(&#123;</span><br><span class="line">        cacheName: &quot;fonts&quot;,</span><br><span class="line">        plugins: [</span><br><span class="line">            new workbox.expiration.ExpirationPlugin(&#123;</span><br><span class="line">                maxEntries: 1000,</span><br><span class="line">                maxAgeSeconds: 60 * 60 * 24 * 30</span><br><span class="line">            &#125;),</span><br><span class="line">            new workbox.cacheableResponse.CacheableResponsePlugin(&#123;</span><br><span class="line">                statuses: [0, 200]</span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Google Fonts</span><br><span class="line">workbox.routing.registerRoute(</span><br><span class="line">    /^https:\/\/fonts\.googleapis\.com/,</span><br><span class="line">    new workbox.strategies.StaleWhileRevalidate(&#123;</span><br><span class="line">        cacheName: &quot;google-fonts-stylesheets&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br><span class="line">workbox.routing.registerRoute(</span><br><span class="line">    /^https:\/\/fonts\.gstatic\.com/,</span><br><span class="line">    new workbox.strategies.CacheFirst(&#123;</span><br><span class="line">        cacheName: &#x27;google-fonts-webfonts&#x27;,</span><br><span class="line">        plugins: [</span><br><span class="line">            new workbox.expiration.ExpirationPlugin(&#123;</span><br><span class="line">                maxEntries: 1000,</span><br><span class="line">                maxAgeSeconds: 60 * 60 * 24 * 30</span><br><span class="line">            &#125;),</span><br><span class="line">            new workbox.cacheableResponse.CacheableResponsePlugin(&#123;</span><br><span class="line">                statuses: [0, 200]</span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Static Libraries</span><br><span class="line">workbox.routing.registerRoute(</span><br><span class="line">    /^https:\/\/cdn\.jsdelivr\.net/,</span><br><span class="line">    new workbox.strategies.CacheFirst(&#123;</span><br><span class="line">        cacheName: &quot;static-libs&quot;,</span><br><span class="line">        plugins: [</span><br><span class="line">            new workbox.expiration.ExpirationPlugin(&#123;</span><br><span class="line">                maxEntries: 1000,</span><br><span class="line">                maxAgeSeconds: 60 * 60 * 24 * 30</span><br><span class="line">            &#125;),</span><br><span class="line">            new workbox.cacheableResponse.CacheableResponsePlugin(&#123;</span><br><span class="line">                statuses: [0, 200]</span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br><span class="line">workbox.googleAnalytics.initialize();</span><br></pre></td></tr></table></figure>
<h4 id="在主题配置文件中，添加需要的-css-和-js"><a href="#在主题配置文件中，添加需要的-css-和-js" class="headerlink" title="在主题配置文件中，添加需要的 css 和 js"></a>在主题配置文件中，添加需要的 css 和 js</h4><pre><code>inject:
  head:
    - &#39;&lt;style type=&quot;text/css&quot;&gt;.app-refresh&#123;position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease&#125;.app-refresh-wrap&#123;display:flex;color:#fff;height:100%;align-items:center;justify-content:center&#125;.app-refresh-wrap a&#123;color:#fff;text-decoration:underline;cursor:pointer&#125;&lt;/style&gt;&#39;
  bottom:
    - &#39;&lt;div class=&quot;app-refresh&quot; id=&quot;app-refresh&quot;&gt; &lt;div class=&quot;app-refresh-wrap&quot;&gt; &lt;label&gt;✨ 网站已更新最新版本 👉&lt;/label&gt; &lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;location.reload()&quot;&gt;点击刷新&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;function showNotification()&#123;if(GLOBAL_CONFIG.Snackbar)&#123;var t=&quot;light&quot;===document.documentElement.getAttribute(&quot;data-theme&quot;)?GLOBAL_CONFIG.Snackbar.bgLight:GLOBAL_CONFIG.Snackbar.bgDark,e=GLOBAL_CONFIG.Snackbar.position;Snackbar.show(&#123;text:&quot;已更新最新版本&quot;,backgroundColor:t,duration:5e5,pos:e,actionText:&quot;点击刷新&quot;,actionTextColor:&quot;#fff&quot;,onActionClick:function(t)&#123;location.reload()&#125;&#125;)&#125;else&#123;var o=`top: 0; background: $&#123;&quot;light&quot;===document.documentElement.getAttribute(&quot;data-theme&quot;)?&quot;#49b1f5&quot;:&quot;#1f1f1f&quot;&#125;;`;document.getElementById(&quot;app-refresh&quot;).style.cssText=o&#125;&#125;&quot;serviceWorker&quot;in navigator&amp;&amp;(navigator.serviceWorker.controller&amp;&amp;navigator.serviceWorker.addEventListener(&quot;controllerchange&quot;,function()&#123;showNotification()&#125;),window.addEventListener(&quot;load&quot;,function()&#123;navigator.serviceWorker.register(&quot;/sw.js&quot;)&#125;));&lt;/script&gt;&#39;
</code></pre>
<p><strong>重点：配置了这些，可能会出现很多问题，本人尝试后有取消了这些配置，谨慎对待，学习学习就好</strong>                                                                                                                                               </p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA</title>
    <url>/2020/08/12/JPA/</url>
    <content><![CDATA[<h3 id="JPA是什么"><a href="#JPA是什么" class="headerlink" title="JPA是什么"></a>JPA是什么</h3><p>JPA（Java Persistence API）Java持久化API。是一套sun公司Java官方制定的ORM方案，是规范，是标准，sun公司自己并没有实现。</p>
<p><strong>关键点：ORM，标准 概念(关键字)</strong></p>
<h3 id="ORM是什么"><a href="#ORM是什么" class="headerlink" title="ORM是什么"></a>ORM是什么</h3><p>ORM（Object Relational Mapping）对象关系映射。问：ORM有什么用？在操作数据库之前，先把数据表与实体类关联起来。然后通过实体类的对象操作（增删改查）数据库表，这个就是ORM的行为！所以：ORM是一个实现使用对象操作数据库的设计思想！通过这句话，我们知道JPA的作用就是通过对象操作数据库的，不用编写sql语句。</p>
<h3 id="JPA的实现者"><a href="#JPA的实现者" class="headerlink" title="JPA的实现者"></a>JPA的实现者</h3><p>既然我们说JPA是一套标准，意味着，它只是一套实现ORM理论的接口。没有实现的代码。那么我们必须要有具体实现者才可以完成ORM操作功能的实现！ </p>
<p>市场上主流的JPA框架（实现者）有：Hibernate(JBoss)、EclipseTop(Eclipse社区)、OpenJPA(Apache基金会)其中Hibernate是众多实现者之中，性能最好的。</p>
<h3 id="JPA的作用是什么"><a href="#JPA的作用是什么" class="headerlink" title="JPA的作用是什么"></a>JPA的作用是什么</h3><p>JPA是ORM的一套标准，既然JPA为ORM而生，那么JPA的作用就是实现使用对象操作数据库，不用写SQL</p>
<p>数据库是用sql操作的，那用对象操作，由谁来产生SQL?</p>
<p>答：JPA实现框架</p>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul>
<li><p>实体（pojo）表示关系数据库中的一个表</p>
</li>
<li><p>每个实体实例对应着该表中的一行</p>
</li>
<li><p>类必须用javax.persistence.Entity注解</p>
</li>
<li><p>类必须含有一个public或者protected的无参构造函数</p>
</li>
<li><p>当实体实例被当做值以分离对象的方式进行传递（例如通过会话bean的远程业务接口）则该类必须实现Serializable（序列化）接口</p>
</li>
<li><p>唯一的对象标志符，简单主键（javax.persistence.Id），复合主键（javax.persistence.EmbeddledId和javax.persistence.IdClass）</p>
</li>
</ul>
<h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><ul>
<li><p>一对一：@OneToOne</p>
</li>
<li><p>一对多：@OneToMany</p>
</li>
<li><p>多对一：@ManyToOne</p>
</li>
<li><p>多对多：@ManyToMany</p>
</li>
</ul>
<h3 id="EntityManager"><a href="#EntityManager" class="headerlink" title="EntityManager"></a>EntityManager</h3><ul>
<li><p>管理实体的一个类，接口</p>
</li>
<li><p>定义与持久性上下文进行交互的方法</p>
</li>
<li><p>创建和删除持久实体类，通过实体的主键查找实体</p>
</li>
<li><p>允许在实体类上进行查询</p>
</li>
</ul>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown小结</title>
    <url>/2020/08/03/Markdown%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>

<h4 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**这是加粗字段**</span><br><span class="line">__这也是加粗字段__</span><br></pre></td></tr></table></figure>

<h4 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*这是倾斜字段*</span><br><span class="line">_这也是倾斜字段_</span><br></pre></td></tr></table></figure>

<h4 id="又斜又粗"><a href="#又斜又粗" class="headerlink" title="又斜又粗"></a>又斜又粗</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">***斜粗字段***</span><br></pre></td></tr></table></figure>

<h4 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==这是高亮字段==</span><br></pre></td></tr></table></figure>

<h4 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2^2^</span><br></pre></td></tr></table></figure>

<h4 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">H~2~o</span><br></pre></td></tr></table></figure>

<h4 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~~加删除线的字段~~</span><br></pre></td></tr></table></figure>

<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;+一个空格+字段</span><br><span class="line">&gt;+五个空格+字段，引用代码块</span><br><span class="line">可以加若干个&gt;嵌套。多级引用</span><br></pre></td></tr></table></figure>

<h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">****</span><br></pre></td></tr></table></figure>

<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![图片alt](图片地址 &quot;图片title&quot;)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure>

<h4 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br><span class="line">如果想要在新页面中打开的话可以用html语言的a标签代替。</span><br><span class="line">&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><h5 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure>
<h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure>
<p>列表嵌套<br>上一级和下一级之间敲三个空格即可</p>
<h4 id="表头"><a href="#表头" class="headerlink" title="表头"></a>表头</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br></pre></td></tr></table></figure>

<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>单行代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\`代码内容\`</span><br></pre></td></tr></table></figure>
<p>代码块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\`\`\`</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">\`\`\`</span><br></pre></td></tr></table></figure>
<p>(使用时 反斜杠去掉)</p>
<h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>

<h4 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h4><p>行内嵌</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$\sum_&#123;i=1&#125;^&#123;10&#125;f(i)\,\,\text&#123;thanks&#125;$</span><br></pre></td></tr></table></figure>
<p>块状</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\sum_&#123;i=1&#125;^&#123;10&#125;f(i)\,\,\text&#123;thanks&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<h4 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h4><p>脚注和注脚一样吗，好像没区别<br>确保 [-] 里面的内容与底部的一致即可，可以是中文</p>
<h4 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h4><p>jump 可以用其他字符或字符串代替，id 一致即可<br>效果与脚注类似，可以跳转之文中任意位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[说明文字](#jump)</span><br><span class="line">&lt;span id=&quot;jump&quot;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h4><p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号<br>例如：你想要用星号加在文字旁边的方式来做出强调效果（为了避免冲突）<br>你可以在星号的前面加上反斜杠，如果不加 \，# 后就会变为一级标题<br>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号</p>
<h4 id="转义箭头"><a href="#转义箭头" class="headerlink" title="转义箭头"></a>转义箭头</h4><p>\to 或 \rightarrow 与前面无空格<br>注意后面有空格！<br>之间若想空格，用 \ 加空格表示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$A\to B$</span><br><span class="line">$C\rightarrow D$</span><br><span class="line">$C\Rightarrow D$</span><br><span class="line">$E\longrightarrow F$</span><br><span class="line">$A\Longleftrightarrow B$</span><br><span class="line">$A\xrightarrow&#123;\ \ \ \ 20km\quad&#125; B$</span><br><span class="line">$Beijin\xrightarrow&#123;10991km)\quad&#125; New York$</span><br></pre></td></tr></table></figure>

<h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">居左：:----</span><br><span class="line">居中：:----:或-----</span><br><span class="line">居右：----:</span><br><span class="line"></span><br><span class="line">|标题|标题|标题|</span><br><span class="line">|:---|:---:|---:|</span><br><span class="line">|居左测试|居中测试|居右测试|</span><br><span class="line">|居左测试1|居中测试1|居右测试1|</span><br><span class="line">|居左测试2|居中测试2|居右测试2|</span><br><span class="line">|居左测试3|居中测试3|居右测试3|</span><br><span class="line"></span><br><span class="line">为了效果，我只能用HTML强制渲染了</span><br><span class="line">|标题|标题|标题|</span><br><span class="line">|:---|:---:|---:|</span><br><span class="line">|居左测试|&lt;center&gt;居中测试&lt;/center&gt;|&lt;p align=&quot;right&quot;&gt;居右测试&lt;/p&gt;|</span><br><span class="line">|居左测试1|&lt;center&gt;居中测试1&lt;/center&gt;|&lt;p align=&quot;right&quot;&gt;居右测试1&lt;/p&gt;|</span><br><span class="line">|居左测试2|&lt;center&gt;居中测试2&lt;/center&gt;|&lt;p align=&quot;right&quot;&gt;居右测试2&lt;/p&gt;|</span><br><span class="line">|居左测试3|&lt;center&gt;居中测试3&lt;/center&gt;|&lt;p align=&quot;right&quot;&gt;居右测试3&lt;/p&gt;|</span><br></pre></td></tr></table></figure>

<h4 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h4><p>任务列表即待办事项，表现为 方框 与 钩</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- [x] 早餐（已完成）</span><br><span class="line">- [ ] 喝水</span><br><span class="line">- [ ] 学习</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<ul>
<li><input checked disabled type="checkbox"> 早餐（已完成）</li>
<li><input disabled type="checkbox"> 喝水</li>
<li><input disabled type="checkbox"> 学习</li>
</ul>
<p>基础markdown语法参考：<a href="https://www.appinn.com/markdown/">https://www.appinn.com/markdown/</a><br>插入数学公式markdown语法参考：<a href="https://www.zybuluo.com/codeep/note/163962">https://www.zybuluo.com/codeep/note/163962</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/2020/11/30/SpringMVC/</url>
    <content><![CDATA[<h3 id="什么是Spring-MVC？简单介绍下你对Spring-MVC的理解？"><a href="#什么是Spring-MVC？简单介绍下你对Spring-MVC的理解？" class="headerlink" title="什么是Spring MVC？简单介绍下你对Spring MVC的理解？"></a>什么是Spring MVC？简单介绍下你对Spring MVC的理解？</h3><p>Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把模型-视图-控制器分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的耦合。</p>
<h3 id="Spring-MVC的优点"><a href="#Spring-MVC的优点" class="headerlink" title="Spring MVC的优点"></a>Spring MVC的优点</h3><ul>
<li>可以支持各种视图技术，而不仅仅局限于JSP</li>
<li>与Spring框架集成（如IoC容器、AOP等）</li>
<li>清晰的角色分配：前端控制器（dispatcherServlet），请求到处理器映射（handleMapping），处理器适配器（HandlerAdapter），视图解析器（ViewResolver）。</li>
<li>支持各种请求资源的映射策略</li>
</ul>
<h3 id="Spring-MVC的主要组件？"><a href="#Spring-MVC的主要组件？" class="headerlink" title="Spring MVC的主要组件？"></a>Spring MVC的主要组件？</h3><ol>
<li>前端控制器DispatcherServlet（不需要程序员开发）<br>作用：接收请求、相应结果，相当于转发器，有了DispatcherServlet就减少了其它组件之间的耦合度</li>
<li>处理器映射器HandlerMapping（不需要程序员开发）<br>作用：根据请求的URL来查找Handler</li>
<li>处理器适配器HandlerAdapter<br>注意：在编写Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。</li>
<li>处理器Handler（需要程序员开发）</li>
<li>视图解析器ViewResolver（不需要程序员开发）<br>作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view）</li>
<li>视图View（需要程序员开发jsp）<br>View是一个接口，它的实现类支持不同的视图类型（jsp, freemarker, pdf等等）</li>
</ol>
<h3 id="什么是DispatcherServlet"><a href="#什么是DispatcherServlet" class="headerlink" title="什么是DispatcherServlet"></a>什么是DispatcherServlet</h3><p>Spring的MVC框架是围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和相应。</p>
<h3 id="什么是Spring-MVC框架的控制器？"><a href="#什么是Spring-MVC框架的控制器？" class="headerlink" title="什么是Spring MVC框架的控制器？"></a>什么是Spring MVC框架的控制器？</h3><p>控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解析用户输入并将其转换为一个由视图呈现给用户的模型。Spring用一个非常抽象的方式实现了一个控制层，允许用户创建多种用途的控制器。</p>
<h3 id="Spring-MVC的控制器是不是单例模式，如果是-有什么问题-怎么解决？"><a href="#Spring-MVC的控制器是不是单例模式，如果是-有什么问题-怎么解决？" class="headerlink" title="Spring MVC的控制器是不是单例模式，如果是 有什么问题 怎么解决？"></a>Spring MVC的控制器是不是单例模式，如果是 有什么问题 怎么解决？</h3><p>是单例模式，所以在多线程访问的时候有线程安全问题，不要用同步，会影响性能的，解决方案是在控制器里面不能写字段。</p>
<h3 id="请描述Spring-MVC的工作流程？描述一下DispatcherServlet的工作流程？"><a href="#请描述Spring-MVC的工作流程？描述一下DispatcherServlet的工作流程？" class="headerlink" title="请描述Spring MVC的工作流程？描述一下DispatcherServlet的工作流程？"></a>请描述Spring MVC的工作流程？描述一下DispatcherServlet的工作流程？</h3><ol>
<li>用户发送请求至前端控制器DispatcherServlet；</li>
<li>DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handle；</li>
<li>处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；</li>
<li>DispatcherServlet 调用 HandlerAdapter处理器适配器；</li>
<li>HandlerAdapter 经过适配调用 具体处理器(Handler，也叫后端控制器)；</li>
<li>Handler执行完成返回ModelAndView；</li>
<li>HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；</li>
<li>DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；</li>
<li>ViewResolver解析后返回具体View；</li>
<li>DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）</li>
<li>DispatcherServlet响应用户。 <img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/11/30/SpringMVC/content1.png" class title="content1"></li>
</ol>
<h3 id="MVC是什么？MVC设计模式的好处有哪些？"><a href="#MVC是什么？MVC设计模式的好处有哪些？" class="headerlink" title="MVC是什么？MVC设计模式的好处有哪些？"></a>MVC是什么？MVC设计模式的好处有哪些？</h3><p>mvc是一种设计模式（设计模式就是日常开发中编写代码的一种好的方法和经验的总结）。<br>模型（model）- 视图（view）- 控制器（controller），三层架构的设计模式。用于实现前端页面的展现与后端业务数据处理的分离。<br>mvc设计模式的好处：</p>
<ol>
<li>分层设计，实现了业务系统各个组件之间的解耦，有利于业务系统的可扩展性，可维护性。</li>
<li>有利于系统的并行开发，提升开发效率。</li>
</ol>
<h3 id="注解原理是什么？"><a href="#注解原理是什么？" class="headerlink" title="注解原理是什么？"></a>注解原理是什么？</h3><p>注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。</p>
<h3 id="Spring-MVC常用的注解有哪些？"><a href="#Spring-MVC常用的注解有哪些？" class="headerlink" title="Spring MVC常用的注解有哪些？"></a>Spring MVC常用的注解有哪些？</h3><p>@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。<br>@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。<br>@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。</p>
<h3 id="Spring-MVC中的控制器的注解一般用哪个，有没有别的注解可以替代？"><a href="#Spring-MVC中的控制器的注解一般用哪个，有没有别的注解可以替代？" class="headerlink" title="Spring MVC中的控制器的注解一般用哪个，有没有别的注解可以替代？"></a>Spring MVC中的控制器的注解一般用哪个，有没有别的注解可以替代？</h3><p>一般用@Controller注解，也可以使用@RestController，@RestController注解相当于@ResponseBody + @Controller，表示是表现层，除此之外，一般不用别的注解代替。</p>
<h3 id="Controller注解的作用"><a href="#Controller注解的作用" class="headerlink" title="@Controller注解的作用"></a>@Controller注解的作用</h3><p>在Spring MVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在Spring MVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。</p>
<p>@Controller 用于标记在一个类上，使用它标记的类就是一个Spring MVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。单单使用@Controller 标记在一个类上还不能真正意义上的说它就是Spring MVC 的一个控制器类，因为这个时候Spring 还不认识它。那么要如何做Spring 才能认识它呢？这个时候就需要我们把这个控制器类交给Spring 来管理。有两种方式：</p>
<ul>
<li>在Spring MVC 的配置文件中定义MyController 的bean 对象。</li>
<li>在Spring MVC 的配置文件中告诉Spring 该到哪里去找标记为@Controller 的Controller 控制器。</li>
</ul>
<h3 id="RequestMapping注解的作用"><a href="#RequestMapping注解的作用" class="headerlink" title="@RequestMapping注解的作用"></a>@RequestMapping注解的作用</h3><p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。<br>RequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。<br><strong>value</strong>， <strong>method</strong><br>value： 指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；<br>method： 指定请求的method类型， GET、POST、PUT、DELETE等；<br><strong>consumes</strong>，<strong>produces</strong><br>consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;<br>produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；<br><strong>params</strong>，<strong>headers</strong><br>params： 指定request中必须包含某些参数值是，才让该方法处理。<br>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。</p>
<h3 id="ResponseBody注解的作用"><a href="#ResponseBody注解的作用" class="headerlink" title="@ResponseBody注解的作用"></a>@ResponseBody注解的作用</h3><p>作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。<br>使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；</p>
<h3 id="PathVariable和-RequestParam的区别"><a href="#PathVariable和-RequestParam的区别" class="headerlink" title="@PathVariable和@RequestParam的区别"></a>@PathVariable和@RequestParam的区别</h3><p>请求路径上有个id的变量值，可以通过@PathVariable来获取 @RequestMapping(value = “/page/{id}”, method = RequestMethod.GET)<br>@RequestParam用来获得静态的URL请求入参 spring注解时action里用到。</p>
<h3 id="Spring-MVC与Struts2区别"><a href="#Spring-MVC与Struts2区别" class="headerlink" title="Spring MVC与Struts2区别"></a>Spring MVC与Struts2区别</h3><p>相同点<br>都是基于mvc的表现层框架，都用于web项目的开发。<br>不同点</p>
<ol>
<li>前端控制器不一样。Spring MVC的前端控制器是servlet：DispatcherServlet。struts2的前端控制器是filter：StrutsPreparedAndExcutorFilter。</li>
<li>请求参数的接收方式不一样。Spring MVC是使用方法的形参接收请求的参数，基于方法的开发，线程安全，可以设计为单例或者多例的开发，推荐使用单例模式的开发（执行效率更高），默认就是单例开发模式。struts2是通过类的成员变量接收请求的参数，是基于类的开发，线程不安全，只能设计为多例的开发。</li>
<li>Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，Spring MVC通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。</li>
<li>与spring整合不一样。Spring MVC是spring框架的一部分，不需要整合。在企业项目中，Spring MVC使用更多一些。</li>
</ol>
<h3 id="Spring-MVC怎么样设定重定向和转发的？"><a href="#Spring-MVC怎么样设定重定向和转发的？" class="headerlink" title="Spring MVC怎么样设定重定向和转发的？"></a>Spring MVC怎么样设定重定向和转发的？</h3><ol>
<li>转发：在返回值前面加”forward:”，譬如”forward:user.do?name=method4”</li>
<li>重定向：在返回值前面加”redirect:”，譬如”redirect:<a href="http://www.baidu.com&quot;/">http://www.baidu.com&quot;</a></li>
</ol>
<h3 id="Spring-MVC怎么和AJAX相互调用的？"><a href="#Spring-MVC怎么和AJAX相互调用的？" class="headerlink" title="Spring MVC怎么和AJAX相互调用的？"></a>Spring MVC怎么和AJAX相互调用的？</h3><p>通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象。具体步骤如下 ：</p>
<ol>
<li>加入Jackson.jar</li>
<li>在配置文件中配置json的映射</li>
<li>在接受Ajax方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解。</li>
</ol>
<h3 id="如何解决POST请求中文乱码问题，GET的又如何处理呢？"><a href="#如何解决POST请求中文乱码问题，GET的又如何处理呢？" class="headerlink" title="如何解决POST请求中文乱码问题，GET的又如何处理呢？"></a>如何解决POST请求中文乱码问题，GET的又如何处理呢？</h3><ol>
<li>解决post请求乱码问题：<br>在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8；<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/11/30/SpringMVC/content2.png" class title="content2">
</li>
<li>get请求中文参数出现乱码解决方法有两个：<br>修改tomcat配置文件添加编码与工程编码一致，如下：<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/11/30/SpringMVC/content3.png" class title="content3">    </li>
</ol>
<p>另外一种方法对参数进行重新编码：<br>String userName = new String(request.getParamter(“userName”).getBytes(“ISO8859-1”),“utf-8”)<br>ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码。        </p>
<h3 id="Spring-MVC的异常处理？"><a href="#Spring-MVC的异常处理？" class="headerlink" title="Spring MVC的异常处理？"></a>Spring MVC的异常处理？</h3><p>可以将异常抛给Spring框架，由Spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。</p>
<h3 id="如果在拦截请求中，我想拦截get方式提交的方法-怎么配置"><a href="#如果在拦截请求中，我想拦截get方式提交的方法-怎么配置" class="headerlink" title="如果在拦截请求中，我想拦截get方式提交的方法,怎么配置"></a>如果在拦截请求中，我想拦截get方式提交的方法,怎么配置</h3><p>可以在@RequestMapping注解里面加上method=RequestMethod.GET。</p>
<h3 id="怎样在方法里面得到Request-或者Session？"><a href="#怎样在方法里面得到Request-或者Session？" class="headerlink" title="怎样在方法里面得到Request,或者Session？"></a>怎样在方法里面得到Request,或者Session？</h3><p>直接在方法的形参中声明request,Spring MVC就自动把request对象传入。</p>
<h3 id="如果想在拦截的方法里面得到从前台传入的参数-怎么得到？"><a href="#如果想在拦截的方法里面得到从前台传入的参数-怎么得到？" class="headerlink" title="如果想在拦截的方法里面得到从前台传入的参数,怎么得到？"></a>如果想在拦截的方法里面得到从前台传入的参数,怎么得到？</h3><p>直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。</p>
<h3 id="如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？"><a href="#如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？" class="headerlink" title="如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？"></a>如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？</h3><p>直接在方法中声明这个对象,Spring MVC就自动会把属性赋值到这个对象里面。</p>
<h3 id="Spring-MVC中函数的返回值是什么？"><a href="#Spring-MVC中函数的返回值是什么？" class="headerlink" title="Spring MVC中函数的返回值是什么？"></a>Spring MVC中函数的返回值是什么？</h3><p>返回值可以有很多类型,有String, ModelAndView。ModelAndView类把视图和数据都合并的一起的，但一般用String比较好。</p>
<h3 id="Spring-MVC用什么对象从后台向前台传递数据的？"><a href="#Spring-MVC用什么对象从后台向前台传递数据的？" class="headerlink" title="Spring MVC用什么对象从后台向前台传递数据的？"></a>Spring MVC用什么对象从后台向前台传递数据的？</h3><p>通过ModelMap对象,可以在这个对象里面调用put方法,把对象加到里面,前台就可以通过el表达式拿到。</p>
<h3 id="怎么样把ModelMap里面的数据放入Session里面？"><a href="#怎么样把ModelMap里面的数据放入Session里面？" class="headerlink" title="怎么样把ModelMap里面的数据放入Session里面？"></a>怎么样把ModelMap里面的数据放入Session里面？</h3><p>可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key。</p>
<h3 id="Spring-MVC里面拦截器是怎么写的"><a href="#Spring-MVC里面拦截器是怎么写的" class="headerlink" title="Spring MVC里面拦截器是怎么写的"></a>Spring MVC里面拦截器是怎么写的</h3><p>有两种写法,一种是实现HandlerInterceptor接口，另外一种是继承适配器类，接着在接口方法当中，实现处理逻辑；然后在Spring MVC的配置文件中配置拦截器即可：   </p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/11/30/SpringMVC/content4.png" class title="content4">  

<h3 id="介绍一下-WebApplicationContext"><a href="#介绍一下-WebApplicationContext" class="headerlink" title="介绍一下 WebApplicationContext"></a>介绍一下 WebApplicationContext</h3><p>WebApplicationContext 继承了ApplicationContext 并增加了一些WEB应用必备的特有功能，它不同于一般的ApplicationContext ，因为它能处理主题，并找到被关联的servlet。                                                                                                                          </p>
]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>xss &amp; sql漏洞解决</title>
    <url>/2021/04/15/xss%20&amp;%20sql%E6%BC%8F%E6%B4%9E%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h3 id="web-xml文件配置"><a href="#web-xml文件配置" class="headerlink" title="web.xml文件配置"></a>web.xml文件配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 解决xss &amp; sql漏洞 --&gt;</span><br><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;xssAndSqlFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;com.guochuang.common.filter.XssAndSqlFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;!-- 解决xss &amp; sql漏洞 --&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;xssAndSqlFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure>

<h3 id="编写过滤器"><a href="#编写过滤器" class="headerlink" title="编写过滤器"></a>编写过滤器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import javax.servlet.Filter;</span><br><span class="line">import javax.servlet.FilterChain;</span><br><span class="line">import javax.servlet.FilterConfig;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import javax.servlet.ServletResponse;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @author BridgeBai</span><br><span class="line"> * extends OncePerRequestFilter</span><br><span class="line"> */</span><br><span class="line">public class XssAndSqlFilter implements Filter  &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">        XssAndSqlHttpServletRequestWrapper xssRequest = new XssAndSqlHttpServletRequestWrapper((HttpServletRequest) request);</span><br><span class="line">        chain.doFilter(xssRequest, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void init(FilterConfig arg0) throws ServletException &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">//   下面是springboot filter配置</span><br><span class="line">//	 //TODO 从配置文件读取</span><br><span class="line">//    private String exclusions = &quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico&quot;;</span><br><span class="line">//    private Set&lt;String&gt; excludesPattern;</span><br><span class="line">//    private PatternMatcher pathMatcher = new ServletPathMatcher();</span><br><span class="line">//</span><br><span class="line">//    public XssAndSqlFilter()&#123;</span><br><span class="line">//            excludesPattern = new HashSet&lt;&gt;(Arrays.asList(exclusions.split(&quot;\\s*,\\s*&quot;)));</span><br><span class="line">//    &#125;</span><br><span class="line">//</span><br><span class="line">//    @Override</span><br><span class="line">//    protected boolean shouldNotFilter(HttpServletRequest request) throws ServletException &#123;</span><br><span class="line">//        String requestURI = request.getRequestURI();</span><br><span class="line">//        String contextPath = request.getContextPath();</span><br><span class="line">//        return isExclusion(requestURI,contextPath);</span><br><span class="line">//    &#125;</span><br><span class="line">//</span><br><span class="line">//    @Override</span><br><span class="line">//    public void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException &#123;</span><br><span class="line">//        XssAndSqlHttpServletRequestWrapper xssRequest = new XssAndSqlHttpServletRequestWrapper(request);</span><br><span class="line">//        chain.doFilter(xssRequest, response);</span><br><span class="line">//    &#125;</span><br><span class="line">//</span><br><span class="line">//    private boolean isExclusion(String requestURI,String contextPath) &#123;</span><br><span class="line">//        if (requestURI == null) &#123;</span><br><span class="line">//            return false;</span><br><span class="line">//        &#125;</span><br><span class="line">//</span><br><span class="line">//        if (contextPath != null &amp;&amp; requestURI.startsWith(contextPath)) &#123;</span><br><span class="line">//            requestURI = requestURI.substring(contextPath.length());</span><br><span class="line">//        &#125;</span><br><span class="line">//</span><br><span class="line">//        for (String pattern : excludesPattern) &#123;</span><br><span class="line">//            if (pathMatcher.matches(pattern, requestURI)) &#123;</span><br><span class="line">//                return true;</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125;</span><br><span class="line">//        return false;</span><br><span class="line">//    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="包装器"><a href="#包装器" class="headerlink" title="包装器"></a>包装器</h3><p>XssAndSqlHttpServletRequestWrapper.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletRequestWrapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @author BridgeBai</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class XssAndSqlHttpServletRequestWrapper extends HttpServletRequestWrapper &#123;</span><br><span class="line"></span><br><span class="line">    public XssAndSqlHttpServletRequestWrapper(HttpServletRequest request) &#123;</span><br><span class="line">        super(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 覆盖getParameter方法，将参数名和参数值都做xss &amp; sql过滤。&lt;br/&gt;</span><br><span class="line">     * 如果需要获得原始的值，则通过super.getParameterValues(name)来获取&lt;br/&gt;</span><br><span class="line">     * getParameterNames,getParameterValues和getParameterMap也可能需要覆盖</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public String getParameter(String name) &#123;</span><br><span class="line">        String value = super.getParameter(HtmlHelper.xssEncode(name));</span><br><span class="line">        if (value != null) &#123;</span><br><span class="line">            value = HtmlHelper.cleanSQLInject(HtmlHelper.xssEncode(value));</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String[] getParameterValues(String s) &#123;</span><br><span class="line">        String str[] = super.getParameterValues(s);</span><br><span class="line">        if (str == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        int i = str.length;</span><br><span class="line">        String as1[] = new String[i];</span><br><span class="line">        for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">            as1[j] = HtmlHelper.cleanSQLInject(HtmlHelper.xssEncode(str[j]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return as1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 覆盖getHeader方法，将参数名和参数值都做xss &amp; sql过滤。&lt;br/&gt;</span><br><span class="line">     * 如果需要获得原始的值，则通过super.getHeaders(name)来获取&lt;br/&gt;</span><br><span class="line">     * getHeaderNames 也可能需要覆盖</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public String getHeader(String name) &#123;</span><br><span class="line"></span><br><span class="line">        String value = super.getHeader(HtmlHelper.xssEncode(name));</span><br><span class="line">        if (value != null) &#123;</span><br><span class="line">            value = HtmlHelper.cleanSQLInject(HtmlHelper.xssEncode(value));</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HtmlHelper.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line">public class HtmlHelper &#123;</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * 将容易引起xss &amp; sql漏洞的半角字符直接替换成全角字符</span><br><span class="line">	 * </span><br><span class="line">	 * @param s</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	public static String xssEncode(String s) &#123;</span><br><span class="line">		if (s == null || s.isEmpty()) &#123;</span><br><span class="line">			return s;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			s = stripXSSAndSql(s);</span><br><span class="line">		&#125;</span><br><span class="line">		/*StringBuilder sb = new StringBuilder(s.length() + 16);</span><br><span class="line">		for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">			char c = s.charAt(i);</span><br><span class="line">			switch (c) &#123;</span><br><span class="line">			case &#x27;&gt;&#x27;:</span><br><span class="line">				sb.append(&quot;＞&quot;);// 转义大于号</span><br><span class="line">				break;</span><br><span class="line">			case &#x27;&lt;&#x27;:</span><br><span class="line">				sb.append(&quot;＜&quot;);// 转义小于号</span><br><span class="line">				break;</span><br><span class="line">			case &#x27;\&#x27;&#x27;:</span><br><span class="line">				sb.append(&quot;＇&quot;);// 转义单引号</span><br><span class="line">				break;</span><br><span class="line">			case &#x27;\&quot;&#x27;:</span><br><span class="line">				sb.append(&quot;＂&quot;);// 转义双引号</span><br><span class="line">				break;</span><br><span class="line">			case &#x27;&amp;&#x27;:</span><br><span class="line">				sb.append(&quot;＆&quot;);// 转义&amp;</span><br><span class="line">				break;</span><br><span class="line">			case &#x27;#&#x27;:</span><br><span class="line">				sb.append(&quot;＃&quot;);// 转义#</span><br><span class="line">				break;</span><br><span class="line">			default:</span><br><span class="line">				sb.append(c);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return sb.toString();*/</span><br><span class="line">		return s;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	 /**</span><br><span class="line">     * 防止xss跨脚本攻击（替换，根据实际情况调整）</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    public static String stripXSSAndSql(String value) &#123;</span><br><span class="line">    	if (value != null) &#123;</span><br><span class="line">            // NOTE: It&#x27;s highly recommended to use the ESAPI library and</span><br><span class="line">            // uncomment the following line to</span><br><span class="line">            // avoid encoded attacks.</span><br><span class="line">            // value = ESAPI.encoder().canonicalize(value);</span><br><span class="line">            // Avoid null characters</span><br><span class="line">            /** value = value.replaceAll(&quot;&quot;, &quot;&quot;); ***/</span><br><span class="line">            // Avoid anything between script tags</span><br><span class="line">            Pattern scriptPattern = Pattern.compile(</span><br><span class="line">                    &quot;&lt;[\r\n| | ]*script[\r\n| | ]*&gt;(.*?)&lt;/[\r\n| | ]*script[\r\n| | ]*&gt;&quot;, Pattern.CASE_INSENSITIVE);</span><br><span class="line">            value = scriptPattern.matcher(value).replaceAll(&quot;&quot;);</span><br><span class="line">            // Avoid anything in a</span><br><span class="line">            // src=&quot;http://www.yihaomen.com/article/java/...&quot; type of</span><br><span class="line">            // e-xpression</span><br><span class="line">            scriptPattern = Pattern.compile(&quot;src[\r\n| | ]*=[\r\n| | ]*[\\\&quot;|\\\&#x27;](.*?)[\\\&quot;|\\\&#x27;]&quot;,</span><br><span class="line">                    Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL);</span><br><span class="line">            value = scriptPattern.matcher(value).replaceAll(&quot;&quot;);</span><br><span class="line">            // Remove any lonesome &lt;/script&gt; tag</span><br><span class="line">            scriptPattern = Pattern.compile(&quot;&lt;/[\r\n| | ]*script[\r\n| | ]*&gt;&quot;, Pattern.CASE_INSENSITIVE);</span><br><span class="line">            value = scriptPattern.matcher(value).replaceAll(&quot;&quot;);</span><br><span class="line">            // Remove any lonesome &lt;script ...&gt; tag</span><br><span class="line">            scriptPattern = Pattern.compile(&quot;&lt;[\r\n| | ]*script(.*?)&gt;&quot;,</span><br><span class="line">                    Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL);</span><br><span class="line">            value = scriptPattern.matcher(value).replaceAll(&quot;&quot;);</span><br><span class="line">            // Avoid eval(...) expressions</span><br><span class="line">            scriptPattern = Pattern.compile(&quot;eval\\((.*?)\\)&quot;,</span><br><span class="line">                    Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL);</span><br><span class="line">            value = scriptPattern.matcher(value).replaceAll(&quot;&quot;);</span><br><span class="line">            // Avoid e-xpression(...) expressions</span><br><span class="line">            scriptPattern = Pattern.compile(&quot;e-xpression\\((.*?)\\)&quot;,</span><br><span class="line">                    Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL);</span><br><span class="line">            value = scriptPattern.matcher(value).replaceAll(&quot;&quot;);</span><br><span class="line">            // Avoid javascript:... expressions</span><br><span class="line">            scriptPattern = Pattern.compile(&quot;javascript[\r\n| | ]*:[\r\n| | ]*&quot;, Pattern.CASE_INSENSITIVE);</span><br><span class="line">            value = scriptPattern.matcher(value).replaceAll(&quot;&quot;);</span><br><span class="line">            // Avoid vbscript:... expressions</span><br><span class="line">            scriptPattern = Pattern.compile(&quot;vbscript[\r\n| | ]*:[\r\n| | ]*&quot;, Pattern.CASE_INSENSITIVE);</span><br><span class="line">            value = scriptPattern.matcher(value).replaceAll(&quot;&quot;);</span><br><span class="line">            // Avoid onload= expressions</span><br><span class="line">            scriptPattern = Pattern.compile(&quot;onload(.*?)=&quot;,</span><br><span class="line">                    Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL);</span><br><span class="line">            value = scriptPattern.matcher(value).replaceAll(&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static String cleanSQLInject(String src) &#123;</span><br><span class="line">        String temp = src;</span><br><span class="line">        src = src.replaceAll(&quot; (?i)insert &quot;, &quot; forbidI &quot;)</span><br><span class="line">                .replaceAll(&quot; (?i)select &quot;, &quot; forbidS &quot;)</span><br><span class="line">                .replaceAll(&quot; (?i)update &quot;, &quot; forbidU &quot;)</span><br><span class="line">                .replaceAll(&quot; (?i)delete &quot;, &quot; forbidD &quot;)</span><br><span class="line">                .replaceAll(&quot; (?i)and &quot;, &quot; forbidA &quot;)</span><br><span class="line">                .replaceAll(&quot; (?i)or &quot;, &quot; forbidO &quot;);</span><br><span class="line">        if (!temp.equals(src)) &#123;</span><br><span class="line">            System.out.println(&quot;输入信息存在SQL攻击！&quot;);</span><br><span class="line">            System.out.println(&quot;原始输入信息--&gt;&quot; + temp);</span><br><span class="line">            System.out.println(&quot;处理后信息--&gt;&quot; + src);</span><br><span class="line">        &#125;</span><br><span class="line">        return src;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title>内外部类互访</title>
    <url>/2020/07/21/%E5%86%85%E5%A4%96%E9%83%A8%E7%B1%BB%E4%BA%92%E8%AE%BF/</url>
    <content><![CDATA[<h3 id="内部类访问外部类"><a href="#内部类访问外部类" class="headerlink" title="内部类访问外部类"></a>内部类访问外部类</h3><p>里面的可以自由访问外面的，规则和static一样。（访问非静态时必须先创建对象）具体如下：</p>
<ul>
<li><p>非静态内部类的非静态方法 直接访问</p>
<p>直接访问</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/07/21/%E5%86%85%E5%A4%96%E9%83%A8%E7%B1%BB%E4%BA%92%E8%AE%BF/content1.png" class title="content1"></li>
<li><p>静态内部类的非静态方法</p>
<p>因为静态方法访问非静态外部成员需先创建实例，所以访问i时必须先new外部类。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/07/21/%E5%86%85%E5%A4%96%E9%83%A8%E7%B1%BB%E4%BA%92%E8%AE%BF/content2.png" class title="content2"></li>
<li><p>静态内部类的静态方法</p>
<p>规则如上</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/07/21/%E5%86%85%E5%A4%96%E9%83%A8%E7%B1%BB%E4%BA%92%E8%AE%BF/content3.png" class title="content3"></li>
</ul>
<h3 id="外部类访问内部类"><a href="#外部类访问内部类" class="headerlink" title="外部类访问内部类"></a>外部类访问内部类</h3><p>大方向：因为将内部类理解为外部类的一个普通成员，所以外面的访问里面的需先new一个对象。</p>
<ul>
<li><p>非静态方法访问非静态内部类的成员：</p>
<p>new 内部类对象</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/07/21/%E5%86%85%E5%A4%96%E9%83%A8%E7%B1%BB%E4%BA%92%E8%AE%BF/content4.png" class title="content4"></li>
<li><p>静态方法访问非静态内部类的成员</p>
<p>静态方法Test2访问非静态Inner1需先new外部类；</p>
<p>继续访问非静态成员i需先new 内部类</p>
<p>所以访问规则为：new Outter().new Inner1().i。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/07/21/%E5%86%85%E5%A4%96%E9%83%A8%E7%B1%BB%E4%BA%92%E8%AE%BF/content5.png" class title="content5"></li>
<li><p>非静态方法访问静态内部类的成员</p>
<p>先“外部类.内部类”访问至内部类。</p>
<p>若访问静态成员，则需先new再访问；若访问非静态成员，则可直接访问。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/07/21/%E5%86%85%E5%A4%96%E9%83%A8%E7%B1%BB%E4%BA%92%E8%AE%BF/content6.png" class title="content6"></li>
<li><p>非静态方法访问非静态内部类的成员</p>
<p>先“外部类.内部类”访问至内部类，再new即可访问静态成员。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/07/21/%E5%86%85%E5%A4%96%E9%83%A8%E7%B1%BB%E4%BA%92%E8%AE%BF/content7.png" class title="content7"></li>
</ul>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类访问外部成员变量时，成员变量前应加final关键字。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/07/21/%E5%86%85%E5%A4%96%E9%83%A8%E7%B1%BB%E4%BA%92%E8%AE%BF/content8.png" class title="content8">















]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>内外部类</tag>
      </tags>
  </entry>
  <entry>
    <title>唯一索引和非唯一索引</title>
    <url>/2020/08/12/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>非唯一索引也叫普通索引</p>
<p>如果在一个列上同时建唯一索引和普通索引的话，mysql 会自动选择唯一索引 唯一索引和普通索引使用的结构都是 B-tree，执行时间复杂度都是 O(log n)</p>
<h3 id="普通索引（非唯一索引）"><a href="#普通索引（非唯一索引）" class="headerlink" title="普通索引（非唯一索引）"></a>普通索引（非唯一索引）</h3><p>普通索引（由关键字 KEY 或 INDEX 定义的索引）的唯一任务是加快对数据的访问速度。因此，应该只为那些最经常出现在查询条件（WHERE column =）或排序条件（ORDER BY column）中的数据列创建索引。只要有可能，就应该选择一个数据最整齐、最紧凑的数据列（如一个整数类型的数据列）来创建索引。</p>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>普通索引允许被索引的数据列包含重复的值</p>
<p>如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字 UNIQUE 把它定义为一个唯一索引。这么做的好处：一是简化了 MySQL 对这个索引的管理工作，这个索引也因此而变得更有效率（区分度：distinct * / count (*) 高）；二是 MySQL 会在有新记录插入数据表时，自动检查新记录的这个字段的值是否已经在某个记录的这个字段里出现过了；如果是，MySQL 将拒绝插入那条新记录。也就是说，唯一索引可以保证数据记录的唯一性。事实上，在许多场合，人们创建唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复。</p>
<h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>主键索引是唯一索引的特殊类型</p>
<p>数据库表通常有一列或列组合，其值用来唯一标识表中的每一行。该列称为表的主键 在数据库关系图中为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的。当在查询中使用主键索引时，它还允许快速访问数据 </p>
<p>它们的一些比较： </p>
<ol>
<li><p>对于主键 MySQL 会自动建立唯一索引；</p>
</li>
<li><p>主键不一定只包含一个字段，所以可以在主键的其中一个字段建唯一索引； </p>
</li>
<li><p>主键可作外键，唯一索引不可；</p>
</li>
<li><p>主键不可为空，唯一索引可； </p>
</li>
<li><p>主键也可是多个字段的组合； </p>
</li>
</ol>
<p>主键与唯一索引不同的是： </p>
<ol>
<li><p>有not null属性； </p>
</li>
<li><p>每个表只能有一个。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列</title>
    <url>/2020/08/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h3><p>可以把消息队列比作是一个存放消息的容器。消息队列是分布式系统中重要的组件，使用消息队列主要是为了通过异步处理提高系统性能和削峰、降低系统耦合性。目前使用较多的消息队列有ActiveMQ，RabbitMQ，Kafka，RocketMQ。</p>
<p>另外，队列Queue是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。比如生产者发送消息1,2,3…对于消费者就会按照1,2,3…的顺序来消费。但是偶尔也会出现消息被消费的顺序不对的情况，比如某个消息消费失败又或者一个queue多个consumer也会导致消息被消费的顺序不对，我们一定要保证消息被消费的顺序正确。</p>
<p>除了上面说的消息消费顺序的问题，使用消息队列，还要考虑如何保证消息不被重复消费？如何保证消息的可靠性传输（如何处理消息丢失的问题）？……等等问题。所以说使用消息队列也不是十全十美的，使用它也会让系统可用性降低、复杂度提高，另外需要我们保障一致性等问题。</p>
<h3 id="为什么要用消息队列"><a href="#为什么要用消息队列" class="headerlink" title="为什么要用消息队列"></a>为什么要用消息队列</h3><p>使用消息队列主要有两点好处：</p>
<ol>
<li>通过异步处理提高系统性能（削峰、减少响应所需时间）；</li>
<li>降低系统耦合性。</li>
</ol>
<p><strong>（1）通过异步处理提高系统性能（削峰、减少响应所需时间)</strong></p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/content1.png" class title="消息队列1">
<p>如上图，<strong>在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求发送给消息队列之后立即返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善</strong>。</p>
<p>通过以上分析可以得出<strong>消息队列具有很好的削峰作用的功能——即通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务</strong>。举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/content2.png" class title="content2">
<p>因为<strong>用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败</strong>。因此使用消息队列进行异步处理之后，需要<strong>适当修改业务流程进行配合</strong>，比如<strong>用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功</strong>，以免交易纠纷。这就类似我们平时手机订火车票和电影票。</p>
<p><strong>（2）降低系统耦合性</strong><br>如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。<br>最常见的<strong>事件驱动架构</strong>类似生产者消费者模式，在大型网站中通常用利用消息队列实现事件驱动结构。如下图所示：</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/content3.png" class title="content3">
<p><strong>消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接收者（消费者）订阅消息</strong>。从上图可以看到<strong>消息发送者（生产者）和消息接收者（消费者）之间没有直接耦合</strong>，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接收者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。<strong>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计</strong>。<br>消息接收者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。</p>
<p><strong>另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息</strong>。</p>
<p><strong>备注</strong>：不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的。<strong>除了发布-订阅模式，还有点对点订阅模式（一个消息只有一个消费者），我们比较常用的是发布-订阅模式</strong>。另外，这两者消息模型是JMS提供的，AMQP协议还提供了5种消息模型。</p>
<h3 id="使用消息队列带来的一些问题"><a href="#使用消息队列带来的一些问题" class="headerlink" title="使用消息队列带来的一些问题"></a>使用消息队列带来的一些问题</h3><ul>
<li>系统可用性降低：系统可用性在某种程度上降低，在加入MQ之前，不用考虑消息丢失或者说MQ挂掉等等的情况，但是，引入MQ之后就需要去考虑了！</li>
<li>系统复杂性提高：加入MQ之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li>
<li>一致性问题：上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了！</li>
</ul>
<h3 id="JMS-VS-AMQP"><a href="#JMS-VS-AMQP" class="headerlink" title="JMS VS AMQP"></a>JMS VS AMQP</h3><h4 id="JMS简介"><a href="#JMS简介" class="headerlink" title="JMS简介"></a>JMS简介</h4><p>JMS（JAVA Message Service，java消息服务）是Java的消息服务，JMS的客户端之间可以通过JMS服务进行异步的消息传输。<strong>JMS API是一个消息服务的标准或者说是规范</strong>，允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。<br><strong>ActiveMQ就是基于JMS规范实现的</strong>。</p>
<h4 id="JMS两种消息模型"><a href="#JMS两种消息模型" class="headerlink" title="JMS两种消息模型"></a>JMS两种消息模型</h4><ol>
<li><p>点到点（P2P）模型</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/content4.png" class title="content4">
<p>使用<strong>队列（Queue）</strong>作为消息通信载体；满足<strong>生产者与消费者模式</strong>，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。比如：生产者发送100条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费）</p>
</li>
<li><p>发布/订阅（Pub/Sub）模型</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/content5.png" class title="content5">
<p>发布订阅模型（Pub/Sub）使用<strong>主题（Topic）</strong>作为消息通信载体，类似于广播模式；发布者发布一条消息，该消息通过主题传递给所有的订阅者，<strong>在一条消息广播之后才订阅的用户则是收不到该条消息的</strong>。</p>
</li>
</ol>
<h4 id="JMS五种不同的消息正文格式"><a href="#JMS五种不同的消息正文格式" class="headerlink" title="JMS五种不同的消息正文格式"></a>JMS五种不同的消息正文格式</h4><p>JMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有的消息格式的一些级别的兼容性。</p>
<ul>
<li>StreamMessage – Java原始值的数据流</li>
<li>MapMessage – 一套名称-值对</li>
<li>TextMessage – 一套字符串对象</li>
<li>ObjectMessage – 一个序列化的Java对象</li>
<li>BytesMessage – 一个字节的数据流</li>
</ul>
<h4 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h4><p>AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准<strong>高级消息队列协议</strong>（二进制应用层协议），是应用层协议的一个开放标准，为面向消息的中间件设计，兼容JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。<br><strong>RabbitMQ就是基于AMQP协议实现的。</strong></p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/content6.png" class title="content6">
<p><strong>总结：</strong></p>
<ul>
<li>AMQP为消息定义了线路层（wire-level protocol）的协议，而JMS所定义的是API规范。在Java体系中，多个client均可以通过JMS进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而AMQP天然具有跨平台、跨语言特性</li>
<li>JMS 支持TextMessage、MapMessage 等复杂的消息类型；而 AMQP 仅支持 byte[] 消息类型（复杂的类型可序列化后发送）</li>
<li>由于Exchange 提供的路由算法，AMQP可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持队列和主题/订阅方式两种</li>
</ul>
<h3 id="常见的消息队列对比"><a href="#常见的消息队列对比" class="headerlink" title="常见的消息队列对比"></a>常见的消息队列对比</h3><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/content7.png" class title="content7">
<p>总结：</p>
<ul>
<li>ActiveMQ 的社区算是比较成熟，但是较目前来说，ActiveMQ 的性能比较差，而且版本迭代很慢，不推荐使用</li>
<li>RabbitMQ 在吞吐量方面虽然稍逊于 Kafka 和 RocketMQ ，但是由于它基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。</li>
<li>RocketMQ 阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的MQ，并且 RocketMQ 有阿里巴巴的实际业务场景的实战考验。RocketMQ 社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准 JMS 规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用RocketMQ 挺好的</li>
<li>kafka 的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。</li>
</ul>
]]></content>
      <categories>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM--1.走近Java</title>
    <url>/2020/09/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM--1.%E8%B5%B0%E8%BF%91Java/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java不仅仅是一门编程语言，它还是一个由一系列计算机软件和规范组成的技术体系，这个技术体系提供了完整的用于软件开发和跨平台部署的支持环境，并广泛应用于嵌入式系统、移动终端、企业服务器、大型机等多种场合。<br>Java优势：</p>
<ul>
<li>结构严谨、面向对象</li>
<li>摆脱硬件平台的束缚，实现“一次编写、到处运行“</li>
<li>提供相对安全的内存管理和访问机制，避免绝大部分内存泄漏和指针越界问题</li>
<li>实现了热点代码检测和运行时编译及优化，使得Java应用能随着运行时间的增长而获得更高的性能</li>
<li>有一套完善的应用程序接口，还有无数来自商业机构和开源社区的第三方类库来帮助用户实现各种各样的功能</li>
</ul>
<h3 id="Java技术体系"><a href="#Java技术体系" class="headerlink" title="Java技术体系"></a>Java技术体系</h3><p>组成部分：</p>
<ol>
<li>Java程序设计语言</li>
<li>各种硬件平台上的Java虚拟机实现</li>
<li>Class文件格式</li>
<li>Java类库API</li>
<li>来自商业机构和开源社区的第三方Java类库<br>Java程序设计语言、Java虚拟机、Java类库这三部分统称为<strong>JDK（Java Development Kit），JDK是用于支持Java程序开发的最小环境</strong>。<br>Java类库API中的Java SE API子集和Java虚拟机这两部分统称为<strong>JRE（Java Runtime Environment），JRE是支持Java程序运行的标准环境</strong>。</li>
</ol>
<p>产品线：</p>
<ol>
<li>Java Card：支持Java小程序（Applets）运行在小内存设备（如智能卡）上的平台。</li>
<li>Java ME(Micro Edition)：支持Java程序运行在移动终端（手机、PDA）上的平台。JDK 6以前被称为J2ME。备注：智能手机上Java开发的Android应用不属于Java ME。</li>
<li>Java SE(Standard Edition)：支持面向桌面级应用（如Windows下的应用程序）的Java平台。JDK 6以前被称为J2SE。</li>
<li>Java EE(Enterprise Edition)：支持使用多层架构的企业应用（如ERP、MIS、CRM应用）的Java平台。JDK 6以前被称为J2EE，在JDK 10以后被Oracle放弃，捐献给Eclipse基金会管理，此后被称为Jakarta EE。</li>
</ol>
]]></content>
      <categories>
        <category>深入理解JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM--2.内存区域与内存溢出</title>
    <url>/2020/09/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM--2.%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>C与C++程序开发中，在内存管理领域中，开发人员即拥有每一个对象的“所有权”，又担负着每一个对象生命从开始到终结的维护责任。<br>Java程序开发中，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，不容易出现内存泄漏和内存溢出问题。但是，一出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那排查错误、修正问题将成为一项异常艰难的工作。<br>Java优势：<strong>内存动态分配；垃圾收集技术</strong>。</p>
<h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/09/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM--2.%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/content1.png" class title="content1">

<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器(Program Counter Register)是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。<br>由于<strong>Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的</strong>，在任何一个确定的时刻，一个处理器(对于多核处理器来说是一个内核)都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“<strong>线程私有</strong>”的内存。<br>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址;如果正在执行的是本地(Native)方法，这个计数器值则应为空(Undefined)。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。      </p>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>与程序计数器一样，Java虚拟机栈(Java Virtual Machine Stack)也是<strong>线程私有</strong>的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型:每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。<br><strong>局部变量表</strong>存放了编译期可知的各种Java虚拟机基本数据类型(boolean、byte、char、short、int、 float、long、double)、对象引用(reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址)。<br>这些数据类型在局部变量表中的存储空间以<strong>局部变量槽</strong>(Slot)来表示，其中64位长度的long和 double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。请读者注意，这里说的“大小”是指变量槽的数量，虚拟机真正使用多大的内存空间(譬如按照1个变量槽占用32个比特、64个比特，或者更多)来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的事情。<br>在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况:<strong>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常;如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常</strong>。      </p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈(Native Method Stacks)与虚拟机栈所发挥的作用是非常相似的，<strong>其区别只是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到的本地(Native)方法服务</strong>。<br>《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机(譬如Hot-Spot虚拟机)直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。      </p>
<h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>对于Java应用程序来说，Java堆(Java Heap)是<strong>虚拟机所管理的内存中最大的一块</strong>。Java堆是被所有<strong>线程共享</strong>的一块内存区域，在虚拟机启动时创建。此内存区域的<strong>唯一目的就是存放对象实例</strong>，Java世界里“几乎”所有的对象实例都在这里分配内存。<br>Java堆是<strong>垃圾收集器管理的内存区域</strong>，因此一些资料中它也被称作“GC堆”(Garbage Collected Heap)。从回收内存的角度看，由于现代垃圾收集器大部分都是基于<strong>分代收集理论</strong>设计的，所以Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From Survivor空间”“To Survivor空间”等名词。<br>如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区 (Thread Local Allocation Buffer，TLAB)，以提升对象分配时的效率。不过无论从什么角度，无论如何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java堆细分的目的只是为了更好地回收内存，或者更快地分配内存。<br>根据《Java虚拟机规范》的规定，Java堆可以<strong>处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的</strong>，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。但对于大对象(典型的如数组对象)，多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。<br>Java堆既<strong>可以被实现成固定大小的，也可以是可扩展的</strong>，不过当前主流的Java虚拟机都是按照可扩展来实现的(通过参数-Xmx和-Xms设定)。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。   </p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区(Method Area)与Java堆一样，是各个<strong>线程共享</strong>的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。虽然《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”(Non-Heap)，目的是与Java堆区分开来。<br>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。      </p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p><strong>运行时常量池(Runtime Constant Pool)是方法区的一部分</strong>。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是<strong>常量池表</strong>(Constant Pool Table)，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。<br>Java虚拟机对于Class文件每一部分(自然也包括常量池)的格式都有严格规定，如每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、加载和执行，但对于运行时常量池，《Java虚拟机规范》并没有做任何细节的要求，不同提供商实现的虚拟机可以按照自己的需要来实现这个内存区域，不过一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。<br>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。<br>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p><strong>直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分</strong>，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。<br>在JDK 1.4中新加入了NIO(New Input/Output)类，引入了一种<strong>基于通道(Channel)与缓冲区 (Buffer)的I/O方式</strong>，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。<br>显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存(包括物理内存、SWAP分区或者分页文件)大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制(包括物理的和操作系统级的限制)，从而导致动态扩展时出现OutOfMemoryError异常。      </p>
<h3 id="HotSpot虚拟机"><a href="#HotSpot虚拟机" class="headerlink" title="HotSpot虚拟机"></a>HotSpot虚拟机</h3><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><ol>
<li>当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程      </li>
<li>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。      </li>
<li>接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码(实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算)、对象的GC分代年龄等信息。这些信息存放在对象的对象头(Object Header)之中。      </li>
<li>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视角看来，对象创建才刚刚开始——构造函数，即Class文件中的&lt;init&gt;()方法还没有执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般来说(由字节码流中new指令后面是否跟随invokespecial指令所决定，Java编译器会在遇到new关键字的地方同时生成这两条字节码指令，但如果直接通过其他方式产生的则不一定如此)，new指令之后会接着执行&lt;init&gt;()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。  </li>
</ol>
<h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分:<strong>对象头</strong>(Header)、<strong>实例数据</strong>(Instance Data)和<strong>对齐填充</strong>(Padding)。      </p>
<ol>
<li>HotSpot虚拟机对象的对象头部分包括两类信息。第一类是用于存储对象自身的<strong>运行时数据</strong>，如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机(未开启压缩指针)中分别为32个比特和64个比特，官方称它 为“Mark Word”。对象头的另外一部分是<strong>类型指针</strong>，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身，      </li>
<li>接下来实例数据部分是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。      </li>
<li>对象的第三部分是对齐填充，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。  </li>
</ol>
<h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>主流的访问方式主要有<strong>使用句柄</strong>和<strong>直接指针</strong>两种:      </p>
<ol>
<li><p>如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。 </p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/09/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM--2.%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/content2.png" class title="content2"></li>
<li><p>如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。   </p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/09/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM--2.%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/content3.png" class title="content3"></li>
</ol>
<p>优势：</p>
<ul>
<li>使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</li>
<li>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。   </li>
</ul>
]]></content>
      <categories>
        <category>深入理解JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM--3.垃圾收集与内存分配</title>
    <url>/2020/10/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM--3.%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>垃圾收集(Garbage Collection，简称GC)思考？</p>
<ul>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？<br>了解垃圾收集和内存分配的意义？<br>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。<br>Java各区域区别？</li>
</ul>
<ol>
<li><strong>程序计数器、虚拟机栈、本地方法栈</strong>3个区域随线程而生，随线程而灭，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的(尽管在运行期会由即时编译器进行一些优化，但在基于概念模型的讨论里，大体上可以认为是编译期可知的)，因此这几个区域的内存分配和回收都具备确定性， 在这几个区域内就<strong>不需要过多考虑如何回收的问题</strong>，当方法结束或者线程结束时，内存自然就跟随着回收了。      </li>
<li><strong>堆和方法区</strong>这两个区域则有着很显著的不确定性:一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾收集器<strong>所关注的正是这部分内存该如何管理</strong>。</li>
</ol>
<h3 id="判断对象是否存活"><a href="#判断对象是否存活" class="headerlink" title="判断对象是否存活"></a>判断对象是否存活</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p><strong>引用计数算法</strong>(Reference Counting)：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一;当引用失效时，计数器值就减一;任何时刻计数器为零的对象就是不可能再被使用的<br>引用计数算法虽然占用了一些额外的内存空间来进行计数，但它的原理简单，判定效率也很高，在大多数情况下它都是一个不错的算法。<br>在Java领域，至少主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数就很难解决对象之间相互循环引用的问题。<br>举个简单的例子，对象objA和objB都有字段instance，赋值令 objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也就无法回收它们。      </p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>当前主流的商用程序语言(Java、C#，上溯至前面提到的古老的Lisp)的内存管理子系统，都是通过<strong>可达性分析</strong>(Reachability Analysis)算法来判定对象是否存活的。这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”(Reference Chain)，如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。<br>例：对象object5、object6、object7虽然互有关联，但是它们到GC Roots是不可达的，因此它们将会被判定为可回收的对象      </p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/10/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM--3.%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/content1.png" class title="content1">

<p>在Java技术体系里面，固定可作为GC Roots的对象包括以下几种: </p>
<ul>
<li>在虚拟机栈(栈帧中的本地变量表)中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。 </li>
<li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。 </li>
<li>在方法区中常量引用的对象，譬如字符串常量池(String Table)里的引用。      </li>
<li>在本地方法栈中JNI(即通常所说的Native方法)引用的对象。 </li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象(比如NullPointExcepiton、OutOfMemoryError)等，还有系统类加载器。 </li>
<li>所有被同步锁(synchronized关键字)持有的对象。</li>
<li>反映Java虚拟机内部情况的JM XBean、JVM TI中注册的回调、本地代码缓存等。<br>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。譬如分代收集和局部回收(Partial GC)，如果只针对Java堆中某一块区域发起垃圾收集时(如最典型的只针对新生代的垃圾收集)，必须考虑到内存区域是虚拟机自己的实现细节(在用户视角里任何内存区域都是不可见的)，更不是孤立封闭的，所以某个区域里的对象完全有可能被位于堆中其他区域的对象所引用，这时候就需要将这些关联区域的对象也一并加入GC Roots集合中去，才能保证可达性分析的正确性。</li>
</ul>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>引用定义： 如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据是代表某块内存、某个对象的引用。<br>在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为<strong>强引用</strong>(Strongly Reference)、<strong>软引用</strong>(Soft Reference)、<strong>弱引用</strong>(Weak Reference)和<strong>虚引用</strong>(Phantom Reference)4种，这4种引用强度依次逐渐减弱。 </p>
<ul>
<li>强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。 </li>
<li>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。</li>
<li>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。 </li>
<li>虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。</li>
</ul>
<h4 id="回收前的finalize"><a href="#回收前的finalize" class="headerlink" title="回收前的finalize()"></a>回收前的finalize()</h4><p>要真正回收一个对象，至少要经历<strong>两次标记</strong>过程:如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。<br>如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为<strong>F-Queue的队列</strong>之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的<strong>Finalizer线程</strong>去执行它们的finalize()方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。 这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。<strong>finalize()方法是对象逃脱死亡命运的最后一次机会</strong>，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对 象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 (this关键字)赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合;如果对象这时候还没有逃脱，那基本上它就真的要被回收了。      </p>
<h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p><strong>方法区的垃圾收集主要回收两部分内容:废弃的常量和不再使用的类型</strong>。<br><strong>回收废弃常量</strong>：举个常量池中字面量回收的例子，假如一个字符串“java”曾经进入常量池中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且垃圾收集器判断确有必要的话，这个“java”常量就将会被系统清理出常量池。常量池中其他类(接口)、方法、字段的符号引用也与此类似。<br><strong>回收类型</strong>: </p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 </li>
<li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。 </li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。<br>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。      </li>
</ul>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h4><p>当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”(Generational Collection)的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上:<br>1)弱分代假说(Weak Generational Hypothesis):绝大多数对象都是朝生夕灭的。<br>2)强分代假说(Strong Generational Hypothesis):熬过越多次垃圾收集过程的对象就越难以消亡。<br>这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则:收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄(年龄即对象熬过垃圾收集过程的次数)分配到不同的区域之中存储。显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间;如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。<br>把分代收集理论具体放到现在的商用Java虚拟机里，设计者一般至少会把Java堆划分为<strong>新生代</strong>(Young Generation)和<strong>老年代</strong>(Old Generation)两个区域。顾名思义，在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。      </p>
<h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>最早出现也是最基础的垃圾收集算法是“标记-清除”(Mark-Sweep)算法。<br>算法分为“标记”和“清除”两个阶段:首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。标记过程就是对象是否属于垃圾的判定过程。<br>它的主要缺点有两个:第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低;第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/10/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM--3.%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/content2.png" class title="content2">

<h4 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h4><p>标记-复制算法常被简称为复制算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。这样实现简单，运行高效，不过其缺陷也显而易见，这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一点。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/10/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM--3.%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/content3.png" class title="content3">

<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以针对老年代对象的存亡特征，另外一种有针对性的“标记-整理”(Mark-Compact)算法，其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。<br>标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策：</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/10/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM--3.%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/content4.png" class title="content4">

]]></content>
      <categories>
        <category>深入理解JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>类的加载方式</title>
    <url>/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="加载方式"><a href="#加载方式" class="headerlink" title="加载方式"></a>加载方式</h3><ol>
<li>隐式加载：new</li>
<li>显式加载：ClassLoader.loadClass和Class.forName</li>
</ol>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>方式1：<br>new通过关键字 然后通过不同的构造器直接创建实例。如：new String() ，new String(“test”)</p>
<p>方式2：<br>需要加载.class文件获取Class对象，通过Class对象，获取构造器，然后调用newInstance方法创建对象实例。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/content1.png" class title="content1">

<h3 id="ClassLoader-loadClass和Class-forName的区别"><a href="#ClassLoader-loadClass和Class-forName的区别" class="headerlink" title="ClassLoader.loadClass和Class.forName的区别"></a>ClassLoader.loadClass和Class.forName的区别</h3><p>Class的装载包括3个步骤：加载（loading），连接（link），初始化（initialize）<br>参考：类的加载过程文档</p>
<p><strong>Class.forName:</strong></p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/content2.png" class title="content2">
<p>forName0第二个参数initialize初始化 这里参数是true说明是初始化过的，因此，静态代码块和静态变量是会被执行和初始化的<br><strong>ClassLoader.loadClass:</strong>  </p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/content3.png" class title="content3">
<p>第二参数resolve，注释中说明这个参数代表是否链接（类加载过程中的链接过程）ClassLoader.loadClass在加载类的过程中只走了第一步</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/content4.png" class title="content4">
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/content5.png" class title="content5">
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/content6.png" class title="content6">

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Class.forName得到的class是已经初始化<br>ClassLoader.loadeClass得到的class是还没有链接的</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>类</tag>
      </tags>
  </entry>
  <entry>
    <title>类的加载过程</title>
    <url>/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="Java-类加载机制"><a href="#Java-类加载机制" class="headerlink" title="Java 类加载机制"></a>Java 类加载机制</h3><p>类从被加载到JVM中开始，到卸载为止，整个生命周期包括：<strong>加载、验证、准备、解析、初始化、使用和卸载七个阶段</strong>。<br>其中类加载过程包括加载、验证、准备、解析和初始化五个阶段。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/content1.png" class title="content1">

<h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ol>
<li>通过类加载器，加载.class文件到内存中。</li>
<li>将读取到.classs数据存储到运行时内存区的方法区。</li>
<li>然后将其转换为一个与目标类型对应的java.lang.Class对象实例。这个Class对象在日后就会作为方法区中该类的各种数据的访问入口。</li>
</ol>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>确保被加载的类（.class文件的字节流），是否按照java虚拟的规范。不会造成安全问题</p>
<ol>
<li>文件格式验证:<br>第一阶段要验证字节流是否符合 Class文件格式的规范, 井且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点：</li>
</ol>
<ul>
<li>是否以魔数 0xCAFEBABE开头</li>
<li>主、次版本号是否在当前虚拟机处理范围之内。</li>
<li>常量池的常量中是否有不被支持的常量类型(检査常量tag 标志)。</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合装型的常量。</li>
<li>CONSTANT_Utf8_info型的常量中是否有不符合 UTF8编码的数据</li>
<li>Class 文件中各个部分及文件本身是否有被删除的或附加的其他信息 实际上第一阶段的验证点还远不止这些, 这是其中的一部分。只有通过了这个阶段的验证之后, 字节流才会进入内存的方法区中进行存储, 所以后面的三个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。</li>
</ul>
<ol start="2">
<li>元数据验证<br>第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求,这个阶段可能包括的验证点如下:</li>
</ol>
<ul>
<li>这个类是否有父类(除了java.lang.object之外,所有的类都应当有父类)</li>
<li>这个类的父类是否继承了不允许被继承的类(被finaI修饰的类)<br>如果这个类不是抽象类, 是否实現了其父类或接口之中要求实现的所有方法类中的字段、方法是否与父类产生了矛盾(例如覆盖了父类的final字段, 或者出現不符合规则的方法重载, 例如方法参数都一致, 但返回值类型却不同等) 第二阶段的验证点同样远不止这些，这一阶段的主要目的是对类的元数据信息进行语义检验, 保证不存在不符合 Java语言规范的元数据信息。</li>
</ul>
<ol start="3">
<li>字节码验证<br>第三阶段是整个验证过程中最复杂的一个阶段, 主要目的是通过数据流和控制流的分析，确定语义是合法的。符号逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为，例如：</li>
</ol>
<ul>
<li>保证任意时刻操作数栈的数据装型与指令代码序列都能配合工作, 例如不会出现类似这样的情况:在操作栈中放置了一个 int类型的数据, 使用时却按long类型来加载入本地变量表中。</li>
<li>保证跳转指令不会跳转到方法体以外的字节码指令上</li>
<li>保证方法体中的类型转换是有效的, 例如可以把一个子类对象赋值给父类数据装型，这是安全的,但是把父类对象意赋值给子类数据类型,甚至把对象赋值给与它毫无继承关系、 完全不相干的一个数据类型, 则是危险和不合法的。 即使一个方法体通过了字节码验证, 也不能说明其一定就是安全的。</li>
</ul>
<ol start="4">
<li>符号引用验证<br>最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候, 这个转化动作将在连接的第三个阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外(常量池中的各种符号引用) 的信息进行匹配性的校验, 通常需要校验以下内容:</li>
</ol>
<ul>
<li>符号引用中通过字将串描述的全限定名是否能找到对应的类</li>
<li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段 。</li>
<li>符号引用中的类、字段和方法的访问性(private、 protected、 public、 default)是否可被当前     类访问</li>
<li>符号引用验证的目的是确保解析动作能正常执行, 如果无法通过符号引用验证, 将会抛出一个java.lang.IncompatibleClassChangError异常的子类, 如 java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。</li>
</ul>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>主要是为类变量（注意，不是实例变量）分配内存，并且赋予初值，此时的赋值是Java虚拟机根据不同变量类型的默认初始值：<br>如8种基本类型的初值，默认为0；引用类型的初值则为null；常量的初值即为代码中设置的值<br> 1、final static temp = 100，此时temp就是赋值 100。<br> 2、String temp = “123456”，此时temp值就是null。<br> 3、int temp = 100，此时temp值就是0。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>将类的二进制数据中的符号引用替换成直接引用（符号引用是用一组符号描述所引用的目标；直接引用是指向目标的指针）<br>可以认为是一些静态绑定的会被解析，动态绑定则只会在运行时进行解析；静态绑定包括一些final方法(不可以重写),static方法(只会属于当前类)，构造器(不会被重写)<br>在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化，则是为标记为常量值的字段赋值的过程。<br>换句话说，只对static修饰的变量或语句块进行初始化。<br>如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。<br>如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。</p>
<h3 id="涉及问题"><a href="#涉及问题" class="headerlink" title="涉及问题"></a>涉及问题</h3><p>一个类的构造器，代码块，静态代码块，成员变量的的执行顺序。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/content2.png" class title="content2">
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/content3.png" class title="content3">
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/content4.png" class title="content4">                                                                                                                                                   ]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>类</tag>
      </tags>
  </entry>
  <entry>
    <title>自动拆装箱</title>
    <url>/2020/07/12/%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/</url>
    <content><![CDATA[<h3 id="什么是自动装箱和拆箱"><a href="#什么是自动装箱和拆箱" class="headerlink" title="什么是自动装箱和拆箱"></a>什么是自动装箱和拆箱</h3><p>自动装箱就是Java自动将原始类型值转换成对应的对象，比如将int的变量转换成Integer对象，这个过程叫做装箱，反之将Integer对象转换成int类型值，这个过程叫做拆箱。因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。原始类型byte, short, char, int, long, float, double 和 boolean 对应的封装类为Byte, Short, Character, Integer, Long, Float, Double, Boolean。</p>
<p>下面例子是自动装箱和拆箱带来的疑惑               </p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/07/12/%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/content1.png" class title="content1"> 
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/07/12/%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/content2.png" class title="content2">    

<h3 id="自动装箱和拆箱的原理"><a href="#自动装箱和拆箱的原理" class="headerlink" title="自动装箱和拆箱的原理"></a>自动装箱和拆箱的原理</h3><p>自动装箱时编译器调用valueOf将原始类型值转换成对象，同时自动拆箱时，编译器通过调用类似intValue(),doubleValue()这类的方法将对象转换成原始类型值。明白自动装箱和拆箱的原理后，我们带着上面的疑问进行分析下Integer的自动装箱的实现源码。如下：</p>
<p>​        <img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/07/12/%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/content3.png" class title="content3"><br>        <img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/07/12/%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/content4.png" class title="content4"></p>
<p>Integer i1 = 40; 自动装箱，相当于调用了Integer.valueOf(40);方法。首先判断i值是否在-128和127之间，如果在-128和127之间则直接从IntegerCache.cache缓存中获取指定数字的包装类；不存在则new出一个新的包装类。</p>
<p>IntegerCache内部实现了一个Integer的静态常量数组，在类加载的时候，执行static静态块进行初始化-128到127之间的Integer对象，存放到cache数组中。cache属于常量，存放在java的方法区中。 </p>
<p>接着看下面是java8种基本类型的自动装箱代码实现。如下：</p>

<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/07/12/%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/content6.png" class title="content6">
<p>通过分析源码发现，只有double和float的自动装箱代码没有使用缓存，每次都是new 新的对象，其它的6种基本类型都使用了缓存策略。<br>使用缓存策略是因为，缓存的这些对象都是经常使用到的（如字符、-128至127之间的数字），防止每次自动装箱都创建一次对象的实例。<br>而double、float是浮点型的，没有特别的热的（经常使用到的）数据的，缓存效果没有其它几种类型使用效率高。<br>下面在看下装箱和拆箱问题解惑。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/07/12/%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/content7.png" class title="content7">]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet基础总结</title>
    <url>/2021/07/14/Servlet%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="Servlet总结"><a href="#Servlet总结" class="headerlink" title="Servlet总结"></a>Servlet总结</h3><p>在Java Web程序中，Servlet主要负责接受用户请求 HttpServletRequest，在doget()，doPost()中做相应的处理，并将回应 HttpServletResponse反馈给用户。Servlet可以设置初始化参数，供Servlet内部使用。一个Servlet类只会有一个实例，在它的初始化时调用init()方法，销毁时调用destroy()方法。Servlet需要在web.xml中配置（MyEclipse中创建Servlet会自动配置），<strong>一个Servlet可以设置多个URL访问。Servlet不是线程安全</strong>，因此要谨慎使用类变量。</p>
<h3 id="阐述Servlet和CGI的区别？"><a href="#阐述Servlet和CGI的区别？" class="headerlink" title="阐述Servlet和CGI的区别？"></a>阐述Servlet和CGI的区别？</h3><ol>
<li><p>CGI的不足之处：<br>(1)需要为每个请求启动一个操作CGI程序的系统进程。如果请求频繁，这将会带来很大的开销。<br>(2)需要为每个请求加载和运行一个CGI程序，这将带来很大的开销<br>(3)需要重复编写处理网络协议的代码以及编码，这些工作都是非常耗时的。</p>
</li>
<li><p>Servlet的优点：<br>(1)只需要启动一个操作系统进程以及加载一个JVM，大大降低了系统的开销<br>(2)如果多个请求需要做同样处理的时候，这时候只需要加载一个类，这也大大降低了开销<br>(3)所有动态加载的类可以实现对网络协议以及请求解码的共享，大大降低了工作量。<br>(4)Servlet能直接和Web服务器交互，而普通的CGI程序不能。Servlet还能在各个程序之间共享数据，使数据库连接池之类的功能很容易实现。<br>补充：Sun Microsystems公司在1996年发布Servlet技术就是为了和CGI进行竞争，Servlet是一个特殊的Java程序，一个基于Java的Web应用通常包含一个或多个Servlet类。Servlet不能够自行创建并执行，它是在Servlet容器中运行的，容器将用户的请求传递给Servlet程序，并将Servlet的响应回传给用户。通常一个Servlet会关联一个或多个JSP页面。以前CGI经常因为性能开销上的问题被诟病，然而Fast CGI早就已经解决了CGI效率上的问题，所以面试的时候大可不必信口开河的诟病CGI，事实上有很多你熟悉的网站都使用了CGI技术。</p>
</li>
</ol>
<h3 id="Servlet接口中有哪些方法及Servlet生命周期探秘"><a href="#Servlet接口中有哪些方法及Servlet生命周期探秘" class="headerlink" title="Servlet接口中有哪些方法及Servlet生命周期探秘"></a>Servlet接口中有哪些方法及Servlet生命周期探秘</h3><p>Servlet接口定义了5个方法，其中前三个方法与Servlet生命周期相关： </p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/07/14/Servlet%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/content1.png" class title="content1">

<p>生命周期： <strong>Web容器加载Servlet并将其实例化后，Servlet生命周期开始</strong>，容器运行其<strong>init()方法</strong>进行Servlet的初始化；请求到达时调用Servlet的<strong>service()<strong>方法，service()方法会根据需要调用与请求对应的</strong>doGet或doPost</strong>等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的<strong>destroy()方法</strong>。<strong>init方法和destroy方法只会执行一次，service方法客户端每次请求Servlet都会执行</strong>。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。</p>
<h3 id="get和post请求的区别"><a href="#get和post请求的区别" class="headerlink" title="get和post请求的区别"></a>get和post请求的区别</h3><p>可以把 get 和 post 当作两个不同的行为，两者并没有什么本质区别，底层都是 TCP 连接。 get请求用来从服务器上获得资源，而post是用来向服务器提交数据。比如你要获取人员列表可以用 get 请求，你需要创建一个人员可以用 post 。这也是 Restful API 最基本的一个要求。</p>
<p>最直观的区别就是<strong>GET把参数包含在URL中，POST通过request body传递参数</strong>。</p>
<ul>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li>
<li>GET产生的URL地址可以被Bookmark，而POST不可以。</li>
<li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li>
<li>GET请求只能进行url编码，而POST支持多种编码方式。</li>
<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>
<li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li>
<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li>
<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>
<li>GET参数通过URL传递，POST放在Request body中。</li>
</ul>
<p>其实，GET和POST本质上没有区别：<br>GET和POST是什么？HTTP协议中的两种发送请求的方法。</p>
<p>HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。<br>HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。</p>
<p>在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩；也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。</p>
<p>但是，我们只看到HTTP对GET和POST参数的传送渠道（url还是requrest body）提出了要求。“标准答案”里关于参数大小的限制又是从哪来的呢？<br>在我大万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器（发起http请求）和服务器（接受http请求）就是不同的运输公司。 虽然理论上，你可以在车顶上无限的堆货物（url中无限加参数）。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。</p>
<p>GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。<br>GET和POST还有一个重大区别，简单的说：<br><strong>GET产生一个TCP数据包；POST产生两个TCP数据包</strong>。</p>
<p>长的说：<br>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；<br>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200(返回数据）。</p>
<p>也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。</p>
<p>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！为什么？</p>
<ol>
<li>GET与POST都有自己的语义，不能随便混用。</li>
<li>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</li>
<li>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</li>
</ol>
<h3 id="什么情况下调用doGet-和doPost-？"><a href="#什么情况下调用doGet-和doPost-？" class="headerlink" title="什么情况下调用doGet()和doPost()？"></a>什么情况下调用doGet()和doPost()？</h3><p>Form标签里的method的属性为get时调用doGet()，为post时调用doPost()。</p>
<h3 id="转发-Forward-和重定向-Redirect-的区别"><a href="#转发-Forward-和重定向-Redirect-的区别" class="headerlink" title="转发(Forward)和重定向(Redirect)的区别"></a>转发(Forward)和重定向(Redirect)的区别</h3><p><strong>转发是服务器行为，重定向是客户端行为</strong>。<br>转发（Forward）<br>通过RequestDispatcher对象的forward（HttpServletRequest request,HttpServletResponse response）方法实现的。RequestDispatcher可以通过HttpServletRequest 的getRequestDispatcher()方法获得。例如下面的代码就是跳转到login_success.jsp页面。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/07/14/Servlet%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/content2.png" class title="content2">

<p>重定向（Redirect）<br>是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过 HttpServletResponse的setStatus(int status)方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源。</p>
<ol>
<li><p>从地址栏显示来说<br>forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.<br>redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.</p>
</li>
<li><p>从数据共享来说<br>forward:转发页面和转发到的页面可以共享request里面的数据.<br>redirect:不能共享数据.</p>
</li>
<li><p>从运用地方来说<br>forward:一般用于用户登陆的时候,根据角色转发到相应的模块.<br>redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等</p>
</li>
<li><p>从效率来说<br>forward:高.<br>redirect:低. </p>
</li>
</ol>
<h3 id="自动刷新-Refresh"><a href="#自动刷新-Refresh" class="headerlink" title="自动刷新(Refresh)"></a>自动刷新(Refresh)</h3><p>自动刷新不仅可以实现一段时间之后自动跳转到另一个页面，还可以实现一段时间之后自动刷新本页面。Servlet中通过HttpServletResponse对象设置Header属性实现自动刷新例如：</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/07/14/Servlet%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/content3.png" class title="content3">

<p>其中5为时间，单位为秒。URL指定就是要跳转的页面（如果设置自己的路径，就会实现每过5秒自动刷新本页面一次）</p>
<h3 id="Servlet与线程安全"><a href="#Servlet与线程安全" class="headerlink" title="Servlet与线程安全"></a>Servlet与线程安全</h3><p>Servlet不是线程安全的，多线程并发的读写会导致数据不同步的问题。 解决的办法是尽量不要定义name属性，而是要把name变量分别定义在doGet()和doPost()方法内。虽然使用synchronized(name){}语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。 注意：多线程的并发的读写Servlet类属性会导致数据不同步。但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此Servlet里的只读属性最好定义为final类型的。</p>
<h3 id="JSP和Servlet是什么关系"><a href="#JSP和Servlet是什么关系" class="headerlink" title="JSP和Servlet是什么关系"></a>JSP和Servlet是什么关系</h3><p>其实这个问题在上面已经阐述过了，Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。JSP本质上是Servlet的一种简易形式，JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然这个说法是很片面且不够准确的。JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。</p>
<h3 id="JSP工作原理"><a href="#JSP工作原理" class="headerlink" title="JSP工作原理"></a>JSP工作原理</h3><p>JSP是一种Servlet，但是与HttpServlet的工作方式不太一样。HttpServlet是先由源代码编译为class文件后部署到服务器下，为先编译后部署。而JSP则是先部署后编译。JSP会在客户端第一次请求JSP文件时被编译为HttpJspPage类（接口Servlet的一个子类）。该类会被服务器临时存放在服务器工作目录里面。下面通过实例给大家介绍。 工程JspLoginDemo下有一个名为login.jsp的Jsp文件，把工程第一次部署到服务器上后访问这个Jsp文件，我们发现这个目录下多了下图这两个东东。 .class文件便是JSP对应的Servlet。编译完毕后再运行class文件来响应客户端请求。以后客户端访问login.jsp的时候，Tomcat将不再重新编译JSP文件，而是直接调用class文件来响应客户端请求。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/07/14/Servlet%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/content4.png" class title="content4">

<p>由于JSP只会在客户端第一次请求的时候被编译 ，因此第一次请求JSP时会感觉比较慢，之后就会感觉快很多。如果把服务器保存的class文件删除，服务器也会重新编译JSP。<br>开发Web程序时经常需要修改JSP。Tomcat能够自动检测到JSP程序的改动。如果检测到JSP源代码发生了改动。Tomcat会在下次客户端请求JSP时重新编译JSP，而不需要重启Tomcat。这种自动检测功能是默认开启的，检测改动会消耗少量的时间，在部署Web应用的时候可以在web.xml中将它关掉。</p>
<h3 id="JSP有哪些内置对象、作用分别是什么？"><a href="#JSP有哪些内置对象、作用分别是什么？" class="headerlink" title="JSP有哪些内置对象、作用分别是什么？"></a>JSP有哪些内置对象、作用分别是什么？</h3><p>JSP有9个内置对象：</p>
<ul>
<li>request：封装客户端的请求，其中包含来自GET或POST请求的参数； </li>
<li>response：封装服务器对客户端的响应；</li>
<li>pageContext：通过该对象可以获取其他对象；</li>
<li>session：封装用户会话的对象；</li>
<li>application：封装服务器运行环境的对象；</li>
<li>out：输出服务器响应的输出流对象；</li>
<li>config：Web应用的配置对象；</li>
<li>page：JSP页面本身（相当于Java程序中的this）；</li>
<li>exception：封装页面抛出异常的对象。</li>
</ul>
<h3 id="Request对象的主要方法有哪些？"><a href="#Request对象的主要方法有哪些？" class="headerlink" title="Request对象的主要方法有哪些？"></a>Request对象的主要方法有哪些？</h3><ol>
<li>setAttribute(String name,Object)：设置名字为name的request 的参数值</li>
<li>getAttribute(String name)：返回由name指定的属性值</li>
<li>getAttributeNames()：返回request 对象所有属性的名字集合，结果是一个枚举的实例</li>
<li>getCookies()：返回客户端的所有 Cookie 对象，结果是一个Cookie 数组</li>
<li>getCharacterEncoding() ：返回请求中的字符编码方式 = getContentLength() ：返回请求的 Body的长度</li>
<li>getHeader(String name) ：获得HTTP协议定义的文件头信息</li>
<li>getHeaders(String name) ：返回指定名字的request Header 的所有值，结果是一个枚举的实例</li>
<li>getHeaderNames() ：返回所以request Header 的名字，结果是一个枚举的实例</li>
<li>getInputStream() ：返回请求的输入流，用于获得请求中的数据</li>
<li>getMethod() ：获得客户端向服务器端传送数据的方法</li>
<li>getParameter(String name) ：获得客户端传送给服务器端的有 name指定的参数值</li>
<li>getParameterNames() ：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例</li>
<li>getParameterValues(String name)：获得有name指定的参数的所有值</li>
<li>getProtocol()：获取客户端向服务器端传送数据所依据的协议名称</li>
<li>getQueryString() ：获得查询字符串</li>
<li>getRequestURI() ：获取发出请求字符串的客户端地址</li>
<li>getRemoteAddr()：获取客户端的 IP 地址</li>
<li>getRemoteHost() ：获取客户端的名字</li>
<li>getSession([Boolean create]) ：返回和请求相关 Session</li>
<li>getServerName() ：获取服务器的名字</li>
<li>getServletPath()：获取客户端所请求的脚本文件的路径</li>
<li>getServerPort()：获取服务器的端口号</li>
<li>removeAttribute(String name)：删除请求中的一个属性</li>
</ol>
<h3 id="request-getAttribute-和request-getParameter-有何区别"><a href="#request-getAttribute-和request-getParameter-有何区别" class="headerlink" title="request.getAttribute()和request.getParameter()有何区别"></a>request.getAttribute()和request.getParameter()有何区别</h3><ol>
<li><p>从获取方向来看：<br>getParameter() 是获取 POST/GET 传递的参数值；<br>getAttribute() 是获取对象容器中的数据值；</p>
</li>
<li><p>从用途来看：<br>getParameter() 用于客户端重定向时，即点击了链接或提交按扭时传值用，即用于在用表单或url重定向传值时接收数据用。<br>getAttribute() 用于服务器端重定向时，即在 sevlet 中使用了 forward 函数,或 struts 中使用了 mapping.findForward。 getAttribute 只能收到程序用 setAttribute 传过来的值。<br>另外，可以用 setAttribute() , getAttribute() 发送接收对象.而 getParameter() 显然只能传字符串。 setAttribute() 是应用服务器把这个对象放在该页面所对应的一块内存中去，当你的页面服务器重定向到另一个页面时，应用服务器会把这块内存拷贝另一个页面所对应的内存中。这样 setAttribute() 就能取得你所设下的值，当然这种方法可以传对象。session也一样，只是对象在内存中的生命周期不一样而已。getParameter() 只是应用服务器在分析你送上来的 request页面的文本时，取得你设在表单或 url 重定向时的值。 </p>
</li>
<li><p>总结：<br>getParameter() 返回的是String,用于读取提交的表单中的值;（获取之后会根据实际需要转换为自己需要的相应类型，比如整型，日期类型啊等等）<br>getAttribute() 返回的是Object，需进行转换,可用 setAttribute() 设置成任意对象，使用很灵活，可随时用</p>
</li>
</ol>
<h3 id="include指令include的行为的区别"><a href="#include指令include的行为的区别" class="headerlink" title="include指令include的行为的区别"></a>include指令include的行为的区别</h3><p>include指令： JSP可以通过include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。包含的文件就好像是该JSP文件的一部分，会被同时编译执行。 语法格式如下： &lt;%@ include file=”文件相对 url 地址” %&gt;<br>include动作： <jsp : include>动作元素用来包含静态和动态的文件。该动作把指定文件插入正在生成的页面。语法格式如下： &lt;jsp:include page=”相对 URL 地址” flush=”true” /&gt;</jsp></p>
<h3 id="讲解JSP中的四种作用域"><a href="#讲解JSP中的四种作用域" class="headerlink" title="讲解JSP中的四种作用域"></a>讲解JSP中的四种作用域</h3><p>JSP中的四种作用域包括page、request、session和application，具体来说：</p>
<ol>
<li>page代表与一个页面相关的对象和属性。</li>
<li>request代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。</li>
<li>session代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。</li>
<li>application代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。</li>
</ol>
<h3 id="如何实现JSP或Servlet的单线程模式"><a href="#如何实现JSP或Servlet的单线程模式" class="headerlink" title="如何实现JSP或Servlet的单线程模式"></a>如何实现JSP或Servlet的单线程模式</h3><p>对于JSP页面，可以通过page指令进行设置。&lt;%@page isTreadSafe=”false”%&gt;<br>对于Servlet，可以让自定义的Servlet实现SingleThreadModel标识接口。<br>说明：如果将JSP或Servlet设置成单线程工作模式，会导致每个请求创建一个Servlet实例，这种实践将导致严重的性能问题（服务器的内存压力很大，还会导致频繁的垃圾回收），所以通常情况下并不会这么做。</p>
<h3 id="实现会话跟踪的技术有哪些"><a href="#实现会话跟踪的技术有哪些" class="headerlink" title="实现会话跟踪的技术有哪些"></a>实现会话跟踪的技术有哪些</h3><ol>
<li><p>使用Cookie<br>向客户端发送Cookie</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/07/14/Servlet%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/content5.png" class title="content5">
<p>从客户端读取Cookie</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/07/14/Servlet%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/content6.png" class title="content6">
<p>优点: 数据可以持久保存，不需要服务器资源，简单，基于文本的Key-Value<br>缺点: 大小受到限制，用户可以禁用Cookie功能，由于保存在本地，有一定的安全风险。</p>
</li>
<li><p>URL 重写<br>在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以标识一个会话。<br>优点： 在Cookie被禁用的时候依然可以使用<br>缺点： 必须对网站的URL进行编码，所有页面必须动态生成，不能用预先记录下来的URL进行访问。</p>
</li>
<li><p>隐藏的表单域</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/07/14/Servlet%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/content7.png" class title="content7">    
<p>优点： Cookie被禁时可以使用<br>缺点： 所有页面必须是表单提交之后的结果。</p>
</li>
<li><p>HttpSession<br>在所有会话跟踪技术中，HttpSession对象是最强大也是功能最多的。当一个用户第一次访问某个网站时会自动创建 HttpSession，每个用户可以访问他自己的HttpSession。可以通过HttpServletRequest对象的getSession方 法获得HttpSession，通过HttpSession的setAttribute方法可以将一个值放在HttpSession中，通过调用 HttpSession对象的getAttribute方法，同时传入属性名就可以获取保存在HttpSession中的对象。与上面三种方式不同的 是，HttpSession放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的Servlet容器可以在内存将满时将HttpSession 中的对象移到其他存储设备中，但是这样势必影响性能。添加到HttpSession中的值可以是任意Java对象，这个对象最好实现了 Serializable接口，这样Servlet容器在必要的时候可以将其序列化到文件中，否则在序列化时就会出现异常。</p>
</li>
</ol>
<h3 id="Cookie和Session的的区别"><a href="#Cookie和Session的的区别" class="headerlink" title="Cookie和Session的的区别"></a>Cookie和Session的的区别</h3><ol>
<li>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</li>
<li>Cookie 一般用来保存用户信息 比如<br>①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；<br>②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；<br>③登录一次网站后访问网站其他页面不需要重新登录。Session 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</li>
<li>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</li>
<li>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring基础</title>
    <url>/2020/08/26/Spring%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="什么是Spring框架？Spring框架有哪些主要模块？"><a href="#什么是Spring框架？Spring框架有哪些主要模块？" class="headerlink" title="什么是Spring框架？Spring框架有哪些主要模块？"></a>什么是Spring框架？Spring框架有哪些主要模块？</h3><p>Spring框架是一个为Java应用程序的开发提供了综合、广泛的基础性支持的Java平台。Spring帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。Spring框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成Spring框架，不必担心Spring是如何在后台进行工作的。<br>Spring框架至今已集成了20多个模块。这些模块主要被分为核心容器、数据访问、集成、web、AOP（面向切面编程）、工具、消息和测试模块。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content1.png" class title="content1">

<h3 id="使用Spring框架能带来的哪些好处？"><a href="#使用Spring框架能带来的哪些好处？" class="headerlink" title="使用Spring框架能带来的哪些好处？"></a>使用Spring框架能带来的哪些好处？</h3><ul>
<li>Dependency Injection(DI)方法使得构造器和JavaBean properties文件中的依赖关系一目了然。  </li>
<li>与EJB容器相比较，IoC容器更加趋向于轻量级。这样一来IoC容器在有限的内存和CPU资源的情况下进行应用程序的开发和发布就变得十分有利。</li>
<li>Spring并没有闭门造车，Spring利用了已有的技术比如ORM框架、logging框架、J2EE、Quartz和JDK Timer，以及其他视图技术。</li>
<li>Spring框架是按照模块的形式来组织的。由包和类的编号就可以看出其所属的模块，开发者仅仅需要选用他们需要的模块即可。</li>
<li>要测试一项Spring开发的应用程序十分简单，因为测试相关的环境代码都已经囊括在框架中了。更加简单的是，利用JavaBean形式的POJO类，可以很方便的利用依赖注入来写入测试数据。</li>
<li>Spring的Web框架亦是一个精心设计的Web MVC框架，为开发者们在Web框架的选择上提供了一个除了主流框架比如Struts、过度设计的、不流行web框架的以外的有力选项。</li>
<li>Spring提供了一个便捷的事务管理接口，适用于小型的本地事物处理（比如在单DB的环境下）和复杂的共同事物处理（比如利用JTA的复杂DB环境）</li>
</ul>
<h3 id="什么是控制反转（IOC）？什么是依赖注入？"><a href="#什么是控制反转（IOC）？什么是依赖注入？" class="headerlink" title="什么是控制反转（IOC）？什么是依赖注入？"></a>什么是控制反转（IOC）？什么是依赖注入？</h3><p>控制反转是应用于软件工程领域中的，在运行时被装配器对象来绑定耦合对象的一种编程技巧，对象之间耦合关系在编译时通常是未知的。在传统的编程方式中，业务逻辑的流程是由应用程序中的早已被设定好关联关系的对象来决定的，该对象关系图由装配器负责实例化，这种实现方式还可以将对象之间的关联关系的定义抽象化。而绑定的过程是通过“依赖注入”实现的。<br>控制反转是一种以给予应用程序中目标组件更多控制为目的设计范式，并在我们的实际工作中起到了有效地作用。<br>依赖注入是编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实例化的模式。这就需要一种机制用来激活相应的组件以提供特定的功能，所以依赖注入是控制反转的基础。否则如果在组件不受框架控制的情况下，框架又怎么知道要创建哪个组件？<br>在Java依赖注入有以下三种实现方式：</p>
<ol>
<li>构造器注入</li>
<li>Setter方法注入</li>
<li>接口注入</li>
</ol>
<h3 id="解释Spring框架中的IoC？"><a href="#解释Spring框架中的IoC？" class="headerlink" title="解释Spring框架中的IoC？"></a>解释Spring框架中的IoC？</h3><p>Spring中的org.springframework.beans包和org.springframework.context包构成了Spring框架IoC容器的基础。<br>BeanFactory接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。ApplicationContext接口对BeanFactory（是一个子接口）进行了扩展，在BeanFactory的基础上添加了其他功能，比如与Spring的AOP更容易继承，也提供了处理message resource的机制（用于国际化）、事件传播以及应用层的特别配置，比如针对Web应用的WebApplicationContext。<br>Org.springframework.beans.factory.BeanFactory是Spring IoC容器的具体实现，用来包装和管理前面提到的各种bean。BeanFactory接口是Spring IoC容器的核心接口。</p>
<h3 id="BeanFactory和ApplicationContext有什么区别？"><a href="#BeanFactory和ApplicationContext有什么区别？" class="headerlink" title="BeanFactory和ApplicationContext有什么区别？"></a>BeanFactory和ApplicationContext有什么区别？</h3><p>BeanFactory可以理解为含有bean集合的工厂类。BeanFactory包含了种bean的定义，以便在接受客户端请求时将对应的bean实例化。<br>BeanFactory还能再实例化对象时生成协作类之间的关系。此举将bean自身与bean客户端的配置中解放出来。BeanFactory还包含了bean生命周期的控制，调用客户端的初始化方法（initialization methods）和销毁方法（destruction methods）。<br>从表面上看，application context如同bean factory一样具有bean定义、bean关联关系的设置，根据请求分发bean的功能。但application context在此基础上还提供了其他的功能。</p>
<ol>
<li>提供了支持国际化的文本消息</li>
<li>统一的资源文件读取方式</li>
<li>已在监听器中注册的bean的事件</li>
</ol>
<p>以下是三种较为常见的ApplicationContext实现方式：<br>1、ClassPathXmlApplicationContext：从classpath的XML配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content2.png" class title="content2">
<p>2、FileSystemXmlApplicationContext：由文件系统中的XML配置文件读取上下文</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content3.png" class title="content3">
<p>3、XmlWebApplicationContext：由Web应用的XML文件读取上下文</p>
<h3 id="Spring有几种配置方式"><a href="#Spring有几种配置方式" class="headerlink" title="Spring有几种配置方式"></a>Spring有几种配置方式</h3><p>将Spring配置到应用开发中有以下三种方式：</p>
<ol>
<li>基于XML的配置</li>
<li>基于注解的配置</li>
<li>基于Java的配置</li>
</ol>
<h3 id="如何用基于XML配置的方式配置Spring？"><a href="#如何用基于XML配置的方式配置Spring？" class="headerlink" title="如何用基于XML配置的方式配置Spring？"></a>如何用基于XML配置的方式配置Spring？</h3><p>在Spring框架中，依赖和服务需要在专门的配置文件来实现，我常用的XML格式的配置文件。这些配置文件的格式通常用<beans>开头，然后一系列的bean定义和专门的应用配置选项组成。<br>SpringXML配置的主要目的时候是使所有的Spring组件都可以用xml文件的形式来进行配置。这意味着不会出现其他的Spring配置类型（比如声明的方式或基于Java Class的配置方式）<br>Spring的XML配置方式是使用被Spring命名空间的所支持的一系列的XML标签来实现的。Spring有以下主要的命名空间：context、beans、jdbc、tx、aop、mvc和aso。</beans></p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content4.png" class title="content4">
<p>下面这个web.xml仅仅配置了DispatcherServlet，这件最简单的配置便能满足应用程序配置运行时组件的需求。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content5.png" class title="content5">

<h3 id="如何用基于Java配置的方式配置Spring？"><a href="#如何用基于Java配置的方式配置Spring？" class="headerlink" title="如何用基于Java配置的方式配置Spring？"></a>如何用基于Java配置的方式配置Spring？</h3><p>Spring对Java配置的支持是由@Configuration注解和@Bean注解来实现的。由@Bean注解的方法将会实例化、配置和初始化一个新对象，这个对象将由Spring的IoC容器来管理。@Bean声明所起到的作用与<bean> 元素类似。被@Configuration所注解的类则表示这个类的主要目的是作为bean定义的资源。被@Configuration声明的类可以通过在同一个类的内部调用@bean方法来设置嵌入bean的依赖关系。<br>最简单的@Configuration 声明类请参考下面的代码：</bean></p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content6.png" class title="content6">
<p>对于上面的@Beans配置文件相同的XML配置文件如下：</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content7.png" class title="content7">
<p>上述配置方式的实例化方式如下：利用AnnotationConfigApplicationContext 类进行实例化</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content8.png" class title="content8">
<p>要使用组件组建扫描，仅需用@Configuration进行注解即可：</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content9.png" class title="content9">
<p>在上面的例子中，com.acme包首先会被扫到，然后再容器内查找被@Component 声明的类，找到后将这些类按照Sring bean定义进行注册。<br>如果你要在你的web应用开发中选用上述的配置的方式的话，需要用AnnotationConfigWebApplicationContext 类来读取配置文件，可以用来配置Spring的Servlet监听器ContrextLoaderListener或者Spring MVC的DispatcherServlet。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content10.png" class title="content10">
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content11.png" class title="content11">

<h3 id="怎样用注解的方式配置Spring？"><a href="#怎样用注解的方式配置Spring？" class="headerlink" title="怎样用注解的方式配置Spring？"></a>怎样用注解的方式配置Spring？</h3><p>Spring在2.5版本以后开始支持用注解的方式来配置依赖注入。可以用注解的方式来替代XML方式的bean描述，可以将bean描述转移到组件类的内部，只需要在相关类上、方法上或者字段声明上使用注解即可。注解注入将会被容器在XML注入之前被处理，所以后者会覆盖掉前者对于同一个属性的处理结果。<br>注解装配在Spring中是默认关闭的。所以需要在Spring文件中配置一下才能使用基于注解的装配模式。如果你想要在你的应用程序中使用关于注解的方法的话，请参考如下的配置</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content12.png" class title="content12">
<p>在<code> &lt;context:annotation-config/&gt;</code>标签配置完成以后，就可以用注解的方式在Spring中向属性、方法和构造方法中自动装配变量。<br>下面是几种比较重要的注解类型：</p>
<ul>
<li>@Required：该注解应用于设值方法。  </li>
<li>@Autowired：该注解应用于有值设值方法、非设值方法、构造方法和变量。  </li>
<li>@Qualifier：该注解和@Autowired注解搭配使用，用于消除特定bean自动装配的歧义。</li>
<li>JSR-250 Annotations：Spring支持基于JSR-250 注解的以下注解，@Resource、@PostConstruct 和@PreDestroy。</li>
</ul>
<h3 id="请解释Spring-Bean的生命周期？"><a href="#请解释Spring-Bean的生命周期？" class="headerlink" title="请解释Spring Bean的生命周期？"></a>请解释Spring Bean的生命周期？</h3><p>Spring Bean的生命周期简单易懂。在一个bean实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个bean不在被调用时需要进行相关的析构操作，并从bean容器中移除。<br>Spring bean factory 负责管理在spring容器中被创建的bean的生命周期。Bean的生命周期由两组回调（call back）方法组成。</p>
<ul>
<li>初始化之后调用的回调方法。  </li>
<li>销毁之前调用的回调方法。<br>Spring框架提供了以下四种方式来管理bean的生命周期事件：  </li>
<li>InitializingBean和DisposableBean回调接口</li>
<li>针对特殊行为的其他Aware接口  </li>
<li>Bean配置文件中的Custom init()方法和destroy()方法  </li>
<li>@PostConstruct和@PreDestroy注解方式<br>使用customInit()和 customDestroy()方法管理bean生命周期的代码样例如下：<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content36.png" class title="content36"></li>
</ul>
<h3 id="Spring-Bean的作用域之间有什么区别？"><a href="#Spring-Bean的作用域之间有什么区别？" class="headerlink" title="Spring Bean的作用域之间有什么区别？"></a>Spring Bean的作用域之间有什么区别？</h3><p>Spring容器中的bean可以分为5个范围。所有范围的名称都是自说明的，但是为了避免混淆，还是让我们来解释一下：</p>
<ul>
<li>singleton：这种bean范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个bean的实例，单例的模式由bean factory自身来维护。</li>
<li>prototype：原形范围与单例范围相反，为每一个bean请求提供一个实例。</li>
<li>request：在请求bean范围内会每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。</li>
<li>Session：与请求范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。</li>
<li>global-session：global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。<br>全局作用域与Servlet中的session作用域效果相同。</li>
</ul>
<h3 id="什么是Spring-inner-beans？"><a href="#什么是Spring-inner-beans？" class="headerlink" title="什么是Spring inner beans？"></a>什么是Spring inner beans？</h3><p>在Spring框架中，无论何时bean被使用时，当仅被调用了一个属性。一个明智的做法是将这个bean声明为内部bean。内部bean可以用setter注入“属性”和构造方法注入“构造参数”的方式来实现。<br>比如，在我们的应用程序中，一个Customer类引用了一个Person类，我们的要做的是创建一个Person的实例，然后在Customer内部使用。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content13.png" class title="content13">
<p>内部bean的声明方式如下：</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content14.png" class title="content14">

<h3 id="Spring框架中的单例Beans是线程安全的吗？"><a href="#Spring框架中的单例Beans是线程安全的吗？" class="headerlink" title="Spring框架中的单例Beans是线程安全的吗？"></a>Spring框架中的单例Beans是线程安全的吗？</h3><p>Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。<br>最浅显的解决办法就是将多态bean的作用域由“singleton”变更为“prototype”。</p>
<h3 id="请举例说明如何在Spring中注入一个Java-Collection？"><a href="#请举例说明如何在Spring中注入一个Java-Collection？" class="headerlink" title="请举例说明如何在Spring中注入一个Java Collection？"></a>请举例说明如何在Spring中注入一个Java Collection？</h3><p>Spring提供了以下四种集合类的配置元素：</p>
<ul>
<li><list> : 该标签用来装配可重复的list值。</list></li>
<li><set> : 该标签用来装配没有重复的set值。</set></li>
<li><map>: 该标签可用来注入键和值可以为任何类型的键值对。</map></li>
<li><props> : 该标签支持注入键和值都是字符串类型的键值对。<br>下面看一下具体的例子：<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content15.png" class title="content15">
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content16.png" class title="content16"></props></li>
</ul>
<h3 id="如何向Spring-Bean中注入一个Java-util-Properties？"><a href="#如何向Spring-Bean中注入一个Java-util-Properties？" class="headerlink" title="如何向Spring Bean中注入一个Java.util.Properties？"></a>如何向Spring Bean中注入一个Java.util.Properties？</h3><p>第一种方法是使用如下面代码所示的<props> 标签：</props></p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content17.png" class title="content17">
<p>也可用”util:”命名空间来从properties文件中创建出一个propertiesbean，然后利用setter方法注入bean的引用。</p>
<h3 id="请解释Spring-Bean的自动装配？"><a href="#请解释Spring-Bean的自动装配？" class="headerlink" title="请解释Spring Bean的自动装配？"></a>请解释Spring Bean的自动装配？</h3><p>在Spring框架中，在配置文件中设定bean的依赖关系是一个很好的机制，Spring容器还可以自动装配合作关系bean之间的关联关系。这意味着Spring可以通过向Bean Factory中注入的方式自动搞定bean之间的依赖关系。自动装配可以设置在每个bean上，也可以设定在特定的bean上。<br>下面的XML配置文件表明了如何根据名称将一个bean设置为自动装配：</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content18.png" class title="content18">
<p>除了bean配置文件中提供的自动装配模式，还可以使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在按照如下的配置方式在Spring配置文件进行配置才可以使用。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content19.png" class title="content19">
<p>也可以通过在配置文件中配置AutowiredAnnotationBeanPostProcessor 达到相同的效果。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content20.png" class title="content20">
<p>配置好以后就可以使用@Autowired来标注了。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content21.png" class title="content21">

<h3 id="请解释自动装配模式的区别？"><a href="#请解释自动装配模式的区别？" class="headerlink" title="请解释自动装配模式的区别？"></a>请解释自动装配模式的区别？</h3><p>在Spring框架中共有5种自动装配，让我们逐一分析。</p>
<ul>
<li>no：这是Spring框架的默认设置，在该设置下自动装配是关闭的，开发者需要自行在bean定义中用标签明确的设置依赖关系。  </li>
<li>byName：该选项可以根据bean名称设置依赖关系。当向一个bean中自动装配一个属性时，容器将根据bean的名称自动在在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错。</li>
<li>byType：该选项可以根据bean类型设置依赖关系。当向一个bean中自动装配一个属性时，容器将根据bean的类型自动在在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错。</li>
<li>constructor：造器的自动装配和byType模式类似，但是仅仅适用于与有构造器相同参数的bean，如果在容器中没有找到与构造器参数类型一致的bean，那么将会抛出异常。</li>
<li>autodetect：该模式自动探测使用构造器自动装配或者byType自动装配。首先，首先会尝试找合适的带参数的构造器，如果找到的话就是用构造器自动装配，如果在bean内部没有找到相应的构造器或者是无参构造器，容器就会自动选择byTpe的自动装配方式。</li>
</ul>
<h3 id="如何开启基于注解的自动装配？"><a href="#如何开启基于注解的自动装配？" class="headerlink" title="如何开启基于注解的自动装配？"></a>如何开启基于注解的自动装配？</h3><p>要使用 @Autowired，需要注册 AutowiredAnnotationBeanPostProcessor，可以有以下两种方式来实现：<br>1、引入配置文件中的<bean>下引入<code>&lt;context:annotation-config&gt;</code></bean></p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content22.png" class title="content22">
<p>2、在bean配置文件中直接引入AutowiredAnnotationBeanPostProcessor</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content23.png" class title="content23">

<h3 id="请举例解释-Required-annotation？"><a href="#请举例解释-Required-annotation？" class="headerlink" title="请举例解释@Required annotation？"></a>请举例解释@Required annotation？</h3><p>在产品级别的应用中，IoC容器可能声明了数十万了bean，bean与bean之间有着复杂的依赖关系。设值注解方法的短板之一就是验证所有的属性是否被注解是一项十分困难的操作。可以通过在<bean>中设置“dependency-check”来解决这个问题。<br>在应用程序的生命周期中，你可能不大愿意花时间在验证所有bean的属性是否按照上下文文件正确配置。或者你宁可验证某个bean的特定属性是否被正确的设置。即使是用“dependency-check”属性也不能很好的解决这个问题，在这种情况下，你需要使用@Required 注解。<br>需要用如下的方式使用来标明bean的设值方法。</bean></p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content24.png" class title="content24">
<p>RequiredAnnotationBeanPostProcessor是Spring中的后置处理用来验证被@Required 注解的bean属性是否被正确的设置了。在使用RequiredAnnotationBeanPostProcesso来验证bean属性之前，首先要在IoC容器中对其进行注册：</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content25.png" class title="content25">
<p>但是如果没有属性被用 @Required 注解过的话，后置处理器会抛出一个BeanInitializationException 异常。</p>
<h3 id="请举例解释-Autowired注解"><a href="#请举例解释-Autowired注解" class="headerlink" title="请举例解释@Autowired注解?"></a>请举例解释@Autowired注解?</h3><p>@Autowired注解对自动装配何时何处被实现提供了更多细粒度的控制。@Autowired注解可以像@Required注解、构造器一样被用于在bean的设值方法上自动装配bean的属性，一个参数或者带有任意名称或带有多个参数的方法。<br>比如，可以在设值方法上使用@Autowired注解来替代配置文件中的 <property>元素。当Spring容器在setter方法上找到@Autowired注解时，会尝试用byType 自动装配。<br>当然我们也可以在构造方法上使用@Autowired 注解。带有@Autowired 注解的构造方法意味着在创建一个bean时将会被自动装配，即便在配置文件中使用<constructor-arg> 元素。</constructor-arg></property></p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content26.png" class title="content26">
<p>下面是没有构造参数的配置方式：</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content27.png" class title="content27">

<h3 id="请举例说明-Qualifier注解？"><a href="#请举例说明-Qualifier注解？" class="headerlink" title="请举例说明@Qualifier注解？"></a>请举例说明@Qualifier注解？</h3><p>@Qualifier注解意味着可以在被标注bean的字段上可以自动装配。Qualifier注解可以用来取消Spring不能取消的bean应用。<br>下面的示例将会在Customer的person属性中自动装配person的值。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content28.png" class title="content28">
<p>下面我们要在配置文件中来配置Person类。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content29.png" class title="content29">
<p>Spring会知道要自动装配哪个person bean么？不会的，但是运行上面的示例时，会抛出下面的异常：</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content30.png" class title="content30">
<p>要解决上面的问题，需要使用 @Quanlifier注解来告诉Spring容器要装配哪个bean：</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content31.png" class title="content31">

<h3 id="构造方法注入和设值注入有什么区别？"><a href="#构造方法注入和设值注入有什么区别？" class="headerlink" title="构造方法注入和设值注入有什么区别？"></a>构造方法注入和设值注入有什么区别？</h3><p>请注意以下明显的区别：</p>
<ul>
<li>在设值注入方法支持大部分的依赖注入，如果我们仅需要注入int、string和long型的变量，我们不要用设值的方法注入。对于基本类型，如果我们没有注入的话，可以为基本类型设置默认值。在构造方法注入不支持大部分的依赖注入，因为在调用构造方法中必须传入正确的构造参数，否则的话为报错。</li>
<li>设值注入不会重写构造方法的值。如果我们对同一个变量同时使用了构造方法注入又使用了设置方法注入的话，那么构造方法将不能覆盖由设值方法注入的值。很明显，因为构造方法尽在对象被创建时调用。  </li>
<li>在使用设值注入时有可能还不能保证某种依赖是否已经被注入，也就是说这时对象的依赖关系有可能是不完整的。而在另一种情况下，构造器注入则不允许生成依赖关系不完整的对象。</li>
<li>在设值注入时如果对象A和对象B互相依赖，在创建对象A时Spring会抛出sObjectCurrentlyInCreationException异常，因为在B对象被创建之前A对象是不能被创建的，反之亦然。所以Spring用设值注入的方法解决了循环依赖的问题，因对象的设值方法是在对象被创建之前被调用的。</li>
</ul>
<h3 id="Spring框架中有哪些不同类型的事件？"><a href="#Spring框架中有哪些不同类型的事件？" class="headerlink" title="Spring框架中有哪些不同类型的事件？"></a>Spring框架中有哪些不同类型的事件？</h3><p>Spring的ApplicationContext 提供了支持事件和代码中监听器的功能。<br>我们可以创建bean用来监听在ApplicationContext 中发布的事件。ApplicationEvent类和在ApplicationContext接口中处理的事件，如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content32.png" class title="content32">
<p>Spring 提供了以下5中标准的事件：</p>
<ul>
<li>上下文更新事件（ContextRefreshedEvent）：该事件会在ApplicationContext被初始化或者更新时发布。也可以在调用ConfigurableApplicationContext      接口中的refresh()方法时被触发。  </li>
<li>上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始/重新开始容器时触发该事件。</li>
<li>上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。</li>
<li>上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</li>
<li>请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。<br>除了上面介绍的事件以外，还可以通过扩展ApplicationEvent 类来开发自定义的事件。<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content33.png" class title="content33">
为了监听这个事件，还需要创建一个监听器：<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content34.png" class title="content34">
之后通过applicationContext接口的publishEvent()方法来发布自定义事件。<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content35.png" class title="content35"></li>
</ul>
<h3 id="FileSystemResource和ClassPathResource有何区别？"><a href="#FileSystemResource和ClassPathResource有何区别？" class="headerlink" title="FileSystemResource和ClassPathResource有何区别？"></a>FileSystemResource和ClassPathResource有何区别？</h3><p>在FileSystemResource 中需要给出spring-config.xml文件在你项目中的相对路径或者绝对路径。在ClassPathResource中spring会在ClassPath中自动搜寻配置文件，所以要把ClassPathResource 文件放在ClassPath下。<br>如果将spring-config.xml保存在了src文件夹下的话，只需给出配置文件的名称即可，因为src文件夹是默认。<br>简而言之，ClassPathResource在环境变量中读取配置文件，FileSystemResource在配置文件中读取配置文件。</p>
<h3 id="Spring框架中都用到了哪些设计模式？"><a href="#Spring框架中都用到了哪些设计模式？" class="headerlink" title="Spring框架中都用到了哪些设计模式？"></a>Spring框架中都用到了哪些设计模式？</h3><p>Spring框架中使用到了大量的设计模式，下面列举了比较有代表性的：</p>
<ul>
<li>代理模式—在AOP和remoting中被用的比较多。  </li>
<li>单例模式—在spring配置文件中定义的bean默认为单例模式。</li>
<li>模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</li>
<li>前端控制器—Srping提供了DispatcherServlet来对请求进行分发。</li>
<li>视图帮助(View Helper )—Spring提供了一系列的JSP标签，高效宏来辅助将分散的代码整合在视图里。</li>
<li>依赖注入—贯穿于BeanFactory / ApplicationContext接口的核心理念。</li>
<li>工厂模式—BeanFactory用来创建对象的实例。 </li>
</ul>
]]></content>
      <categories>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>初识Activiti工作流</title>
    <url>/2021/02/06/%E5%88%9D%E8%AF%86Activiti%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
    <content><![CDATA[<h3 id="工作流介绍"><a href="#工作流介绍" class="headerlink" title="工作流介绍"></a>工作流介绍</h3><p>工作流（Workflow），是对工作流程及其各操作步骤之间业务规则的抽象、概括、描述。<br>工作流要解决的主要问题：为实现某个业务目标，在多个参与者之间，利用计算机，按某种预定规则自动传递文档、信息或者任务。</p>
<h3 id="BPMN-2-0规范简述"><a href="#BPMN-2-0规范简述" class="headerlink" title="BPMN 2.0规范简述"></a>BPMN 2.0规范简述</h3><p>BPMN规范，全称是Business Process Modeling Notation（1.0-2004），BPMN规范的发布为了让业务流程的全部参与人员对流程可以进行可视化管理，提供一套让所有参与人员都易于理解的语言和标记。<br>2.0 版本于2011年发布，全称改为Business Process Model And Notation（业务流程模型和符号）</p>
<p>BPMN2.0在以下方面扩展了BPMN1.2：</p>
<ul>
<li>规范了流程元素的执行语法。</li>
<li>定义了流程模型和流程图的扩展机制。</li>
<li>细化了事件的组成。</li>
<li>扩展了参与者的交互定义。</li>
<li>定义了编排模型。</li>
</ul>
<p>BPMN 2.0的<strong>目的</strong>是建议简单并且易懂的业务流程模型，但是同时又需要处理高度复杂的业务流程，因此要解决这两个矛盾的要求，需要在规范中定义标准的图形和符号。</p>
<p>BPMN中定义了5个基础的元素类别：</p>
<ol>
<li>流对象（Flow Objects）：在一个业务流程中，流对象是用于定义行为的图形元素，主要有事件（Events）、活动（Activities）和网关（Gateways）三种流对象。</li>
<li>数据（Data）：主要有数据对象（Data Object）、数据输入（Data Inputs）、数据输出（Data Outputs）和数据存储（Data Stores）4种元素。</li>
<li>连接对象（Connecting Objects）：用于连接流对象，主要有4种连接流对象的方式，包括顺序流（Sequence Flows）、消息流（Message Flows）、关联（Associations）和数据关联（Data Associations）</li>
<li>泳道（Swimlanes）：泳道有两种途径组织基础的模型元素，分别是池（Pools）和道（Lanes）。</li>
<li>制品（Artifacts）：制品主要用于为流程提供附件信息，当前制品包括组（Group）和注释（Text Annotation）。</li>
</ol>
<p>BPMN元素的图形及其描述：</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/06/%E5%88%9D%E8%AF%86Activiti%E5%B7%A5%E4%BD%9C%E6%B5%81/content1.png" class title="content1">       
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/06/%E5%88%9D%E8%AF%86Activiti%E5%B7%A5%E4%BD%9C%E6%B5%81/content2.png" class title="content2"> 

<h3 id="Activiti数据库设计"><a href="#Activiti数据库设计" class="headerlink" title="Activiti数据库设计"></a>Activiti数据库设计</h3><p><strong>Activiti流程引擎的数据表分5大类</strong>：</p>
<ol>
<li>通用数据表</li>
<li>流程存储数据表</li>
<li>身份数据表</li>
<li>运行时数据表</li>
<li>历史数据表<br>Activiti 6.0版本种加入了基于DMN规范的规则引擎，DMN规则引擎数据表</li>
</ol>
<h4 id="通用数据表："><a href="#通用数据表：" class="headerlink" title="通用数据表："></a>通用数据表：</h4><p>用于存放一些通用的数据，这些表本身不关心特定的流程或者业务，只用于存放这些业务或者流程所使用的通用资源。<br>通用数据表有两个，都以“ACT_GE”开头，GE是单词general的缩写。</p>
<ul>
<li>资源表：表ACT_GE_BYTEARRAY用于保存与流程引擎相关的资源，只要调用了Activiti存储服务的API，涉及的资源均会被转换为byte数据保存到这个表中。使用这个表来保存字符串、流程文件</li>
<li>属性表：Activiti将全部的属性抽象为 key-value 对，每个属性都有名称和值，使用ACT_GE_PROPERTY来保存这些属性</li>
</ul>
<h4 id="流程存储表："><a href="#流程存储表：" class="headerlink" title="流程存储表："></a>流程存储表：</h4><p>使用仓储表来保存流程定义和部署信息这类数据，存储表名称以“ACT_RE”开头，“RE”是repository单词的缩写。</p>
<ul>
<li>部署数据表：在Activiti中，一次部署可以添加多个资源，资源会被保存到资源表中（ACT_GE_BTYEARRAY），而对于部署，则部署信息会被保存到部署表中（ACT_RE_DEPLOYMENT）</li>
<li>流程定义表：Activiti在部署添加资源时，如果发布部署的文件是流程文件（.bpmn或者.BPMN20.xml），则除了会解析解析流程文件，将内容保存到资源表外，还会解析流程文件的内容，形成特定的流程定义数据，写入流程定义表（ACT_RE_PROCDEF）中。</li>
</ul>
<h4 id="身份数据表："><a href="#身份数据表：" class="headerlink" title="身份数据表："></a>身份数据表：</h4><p>Activiti的整个身份数据模块，可以独立于流程引擎而存在，有关身份数据的几张表，并没有保存与流程相关的数据及关联。身份表名称以ACT_ID开头，表名中的”ID”是单词identity的缩写。</p>
<ul>
<li>用户表：流程引擎用户的信息被保存在ACT_ID_USER表中</li>
<li>用户账号（信息）表：Activiti将用户、用户账号和用户信息分为三种数据，其中用户表保存用户的数据，而用户账号和用户信息，则被保存到ACT_ID_INFO表中。</li>
<li>用户组表：使用ACT_ID_GROUP表来保存用户组的数据</li>
<li>关系表：一个用户组下有多个用户，一个用户可以属于不同的用户组，那么这种多对多的关系就使用关系表来进行描述，关系表为ACT_ID_MEMBERSHIP</li>
</ul>
<h4 id="运行时数据表："><a href="#运行时数据表：" class="headerlink" title="运行时数据表："></a>运行时数据表：</h4><p>运行时数据表用来保存流程在运行过程中所产生的数据，例如流程实例、执行流、任务等。<br>运行时数据表的名称以ACT_RU开头，”RU”是单词runtime的缩写。</p>
<ul>
<li>流程实例（执行流）表：流程启动后，会产生一个流程实例，同时会产生相应的执行流，流程实例和执行流数据均被保存在ACT_RU_EXECUTION表中，如果一个流程实例只有一条执行流，那么该表中只产生一条数据，该数据既表示执行流，也表示流程实例。</li>
<li>流程任务表：流程在运行过程中所产生的任务数据保存在ACT_RU_TASK表中</li>
<li>流程参数表：ACT_RU_VARIABLE表来存放流程中的参数，这类参数包括流程实例参数、执行流参数和任务参数，参数有可能会有多种类型</li>
<li>流程与身份关系表：用户组和用户之间的关系，使用ACT_ID_MEMBERSHIP表来保存，用户或者用户组与流程数据之间的关系，则使用ACT_RU_IDENTITYLINK表来保存，相比于ACT_ID_MEMBERSHIP表，ACT_RU_IDENTITYLINK表的字段更多一些。</li>
<li>工作数据表：在流程执行的过程中，会有一些工作需要定时或者重复执行，这类工作数据被保存到工作表中</li>
<li>事件描述表：如果流程到达某类事件节点，Activiti会往ACT_RU_EVENT_SUBSCR表中加入事件描述数据，这些事件描述数据将会决定流程事件的触发。</li>
</ul>
<h4 id="历史数据表："><a href="#历史数据表：" class="headerlink" title="历史数据表："></a>历史数据表：</h4><p>历史数据表就好像流程引擎的日志表，操作过的流程元素将会被记录到历史表中。历史数据表名称以ACT_HI开头，“HI”是单词history的缩写。</p>
<ul>
<li>流程实例表：流程实例的历史数据会被保存到ACT_HI_PROCINST表中，只要流程被启动，就会将流程实例的数据写入表中。除了基本的流程字段外，与运行时数据表不同的是，历史流程实例表还会记录流程开始活动ID、结束活动ID等信息。</li>
<li>流程明细表：ACT_HI_DETAIL会记录流程执行过程中的参数或者表单数据，由于在流程执行过程中，会产生大量这类数据，因此默认情况下，Activiti不会保存流程明细数据，除非将流程引擎的历史数据（history）配置为null</li>
<li>历史任务表和历史行为表：当流程到达某个任务节点时，就会向历史任务表（ACT_HI_TASKINST）中写入历史任务数据，该表在运行时的任务表类似。历史行为表（ACT_HI_ACTINST）会记录每一个流程活动的实例，一个流程活动将会被记录为一条数据，根据该表可以追踪最完整的流程信息。</li>
<li>附件表和评论表：使用任务服务（TasjService）的API，可以添加附件和评论，这些附件和评论的数据将会被保存到ACT_HI_ATTACHMENT和ACT_HI_COMMENT表中。ACT_HI_COMMENT表实际不只保存评论数据，它还会保存某些事件数据，但它的表名为COMMENT，因此更倾向把它叫做评论表。虽然附件表和评论表的命名遵守历史数据表的命名规范（以ACT_HI开头），但是可以调用其他服务组件的API来往这两张表中写入数据。历史数据表实际上保存的是那种一经写入，就很少会发生变化（结构性变化）的数据。</li>
</ul>
<h4 id="DMN规范引擎表："><a href="#DMN规范引擎表：" class="headerlink" title="DMN规范引擎表："></a>DMN规范引擎表：</h4><p>Activiti 6.0中加入了基于DMN规范的规则引擎模块，当前版本主要有三个数据表，保存规则引擎相关的数据。</p>
<ul>
<li>决策部署表：保存决策数据，类似于流程定义部署，每一次部署，可以添加多份决策文件，向部署表中写入一条部署数据，对应数据表为ACT_DMN_DEPLOYMENT。</li>
<li>决策表：可以先将决策看作流程定义，决策文件中保存着决策表，部署时会解析决策文件中的决策模型并将其保存到ACT_DMN_DECISION_TABLE表中。</li>
<li>部署资源表：规则引擎相关的资源，例如决策文件、图片等，被保存在ACT_DMN_DEPLOYMENT_RESOURCE表中，该表类似流程引擎的资源表。</li>
</ul>
<h3 id="Activiti流程引擎"><a href="#Activiti流程引擎" class="headerlink" title="Activiti流程引擎"></a>Activiti流程引擎</h3><p><strong>ProcessEngineConfiguration对象</strong>代表一个Activiti流程引擎的全部配置，该类提供一系列创建 ProcessEngineConfiguration 实例的静态方法，这些方法用于读取和解析相应的配置文件，并返回 ProcessEngineConfiguration 的实例。</p>
<p>使用静态方法创建 ProcessEngineConfiguration 实例：</p>
<ol>
<li><p>读取默认的配置文件<br>ProcessEngineConfiguration 对象的 createProcessEngineConfigurationFromResourceDefault 方法， 使用Activiti默认的方式创建ProcessEngineConfiguration的实例。这里所说的默认方式，是<strong>指由Activiti决定读取配置文件的位置、文件的名称和配置bean的名称这些信息</strong>。Activiti默认到ClassPath下读取名为”activiti.cfg.xml”的Activiti配置文件，启动并获取名称为 “processEngineConfiguration”的bean的实例。解析XML与创建该bean实例的过程，由Spring 代为完成。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/06/%E5%88%9D%E8%AF%86Activiti%E5%B7%A5%E4%BD%9C%E6%B5%81/content3.png" class title="content3"></li>
<li><p>读取自定义的配置文件<br>默认情况下Activiti将到ClassPath下读取activiti.cfg.xml文件，如果希望 Activiti 读取另外名称的配置文件，则可以使用 createProcessEngineConfigurationFromResource 方法创建ProcessEngineConfiguration,该方法参数为一个字符串对象，当调用该方法时，需要告诉 Activiti 配置文件的位置。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/06/%E5%88%9D%E8%AF%86Activiti%E5%B7%A5%E4%BD%9C%E6%B5%81/content4.png" class title="content4"></li>
<li><p>读取输入流的配置<br>ProcessEngineConfiguration对象中提供了一个createProcessEngineConfigurationFromInputStream方法，该方法使得Activiti配置文件的加载不再局限于项目的ClassPath，只要得到配置文件的输入流， 即可创建 ProcessEngineConfiguration。createProcessEngineConfigurationFromInputStream方法，提供了两个重载的方法，可以指定在解析XML时bean的名称。 </p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/06/%E5%88%9D%E8%AF%86Activiti%E5%B7%A5%E4%BD%9C%E6%B5%81/content5.png" class title="content5"></li>
<li><p>使用createStandaloneInMemProcessEngineConfiguration方法<br>使用该方法创建ProcessEngineConfiguration，并不需要指定任务参数，该方法直接返回一 个 StandalonelnMemProcessEngineConfiguration 实例，该类为 ProcessEngineConfiguration 的子类。使用该方法创建ProcessEngineConfiguration，并不会读取任何的Activiti配置文件，这就意味着流程引擎配置的全部属性都会使用默认值。与其他子类不一样的是, 创建的 StandalonelnMemProcessEngineConfiguration 实例，只特别指定了 databaseSchemaUpdate 属性和jdbcUrl属性。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/06/%E5%88%9D%E8%AF%86Activiti%E5%B7%A5%E4%BD%9C%E6%B5%81/content6.png" class title="content6"></li>
<li><p>使用createStandaloneProcessEngineConfiguration方法<br>createStandaloneProcessEngineConfiguration 方法实际返回一个 StandaloneProcessEngineConfiguration 实例，需要注意的是，StandaloneInMemProcessEngineConfiguration类是 StandaloneProcessEngineConfiguration 类的子类。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/06/%E5%88%9D%E8%AF%86Activiti%E5%B7%A5%E4%BD%9C%E6%B5%81/content7.png" class title="content7"></li>
</ol>
<h3 id="数据源配置"><a href="#数据源配置" class="headerlink" title="数据源配置"></a>数据源配置</h3><p>Activiti在启动时，会读取相应的数据源配置，用于对数据库进行相应的操作。Activiti会先读取配置文件，然后取得配置的bean,并对其进行初始化。</p>
<p><strong>Activiti支持的数据库</strong><br>Activiti默认支持H2数据库，H2是一个开源的嵌入式数据库，是使用Java语言编写的。 使用H2数据库不需要安装服务器或者客户端，只需提供一个jar包即可使用。在实际的企业应用中，很少会使用这种轻量级的嵌入式数据库，因此H2数据库更适合单元测试。除了 H2 数据库，Activiti还对以下数据库提供支持。</p>
<ul>
<li>MySQL：主流数据库之一，它是一个开源的小型关系型数据库，由于它体积小、速度快，得到相当多开发者的青睐，并且最重要的是，它是免费的。</li>
<li>Oracle：目前世界上最流行的商业数据库，价格昂贵，但是它高效的性能、可靠的数据管理，仍令不少企业心甘情愿为其掏钱。</li>
<li>PostgreSQL：PostgreSQL是另外一款开源的数据库。</li>
<li>DB2：由IBM公司研发的一款关系型数据库，其良好的伸缩性和高效性，让它成为继 Oracle之后又一强大的商业数据库。</li>
<li>MSSQL：微软研发的一款数据库产品，目前也支持在Linux下使用。</li>
</ul>
<p><strong>Activiti 与 Spring</strong><br>Spring是目前非常流行的一个轻量级J2EE框架，它提供了一套轻量级的企业应用解决方案，包括IoC容器、AOP面向切面技术以及WebMVC框架等。<br>使用Activiti的项目，并不意味着一定要使用Spring，Activiti可以在任何有或者没有Spring 的环境中使用。虽然Activiti并不需要使用Spring环境，但是Activiti在创建流程引擎时，使用了 Spring的XML解析与依赖注入功能ProcessEngineConfiguration对应的配置，即为Spring 中的一个bean。</p>
<p><strong>JDBC 配置</strong><br>使用JDBC连接数据库，需要使用jdbc url、 jdbc驱动、数据库用户名和密码。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/06/%E5%88%9D%E8%AF%86Activiti%E5%B7%A5%E4%BD%9C%E6%B5%81/content8.png" class title="content8">

<p><strong>DBCP数据源配置</strong><br>DBCP是Apache提供的一-个数据库连接池。ProcessEngineConfiguration中提供了一个 dataSource属性，如果用户不希望直接将JDBC的相关连接属性交给Activiti，可以自己创建数据库连接，然后通过这个dataSource属性设置到ProcessEngineConfiguration中。为Activiti的 ProcessEngineConfiguration设置dataSource，可以采用配置或者编码的方式。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/06/%E5%88%9D%E8%AF%86Activiti%E5%B7%A5%E4%BD%9C%E6%B5%81/content9.png" class title="content9">

<p><strong>C3P0数据源配置</strong><br>与DBCP类似，C3P0也是一个开源的数据库连接池，它们都被广泛地应用到开源项目以 及企业应用中。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/06/%E5%88%9D%E8%AF%86Activiti%E5%B7%A5%E4%BD%9C%E6%B5%81/content10.png" class title="content10">

<p><strong>Activiti其他数据源配置</strong><br>如果不使用第三方数据源，直接使用Activiti提供的数据源，那么还可以指定其他一些数据库属性。Activiti默认使用的是myBatis的数据连接池，因此ProcessEngineConfiguration中也提供了一些MyBatis的配置。<br>jdbcMaxActiveConnections: 在数据库连接池内最大的活跃连接数，默认值为10。<br>jdbcMaxIdleConnections: 连接池最大的空闲连接数。<br>jdbcMaxCheckoutTime：当连接池内的连接耗尽，外界向连接池请求连接时，创建连接的等待时间，单位为毫秒，默认值为20000,即20秒。<br>jdbcMaxWaitTime：当整个连接池需要重新获取连接的时候，设置等待的时间，单位为毫秒，默认值为20000,即20秒。</p>
<p><strong>数据库策略配置</strong><br>ProcessEngineConfiguration提供了 databaseSchemaUpdate属性，该项可以设置流程引擎启动 和关闭时数据库执行的策略。在Activiti的官方文档中，databaseSchemaUpdate有以下三个值。<br>false： false为默认值，若设置为该值，Activiti在启动时，会对比数据库表中保存的版本，如果没有表或者版本不匹配，将在启动时抛出异常。<br>true： 若设置为该值，Activiti会对数据库中所有的表进行更新,如果表不存在，则Activiti会自动创建。<br>create-drop： Activiti启动时，会执行数据库表的创建操作。而Activiti关闭吋，执行数据库表的删除操作。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/06/%E5%88%9D%E8%AF%86Activiti%E5%B7%A5%E4%BD%9C%E6%B5%81/content11.png" class title="content11">

<p><strong>databaseType 配置</strong><br>将databaseSchemaUpdate设置为create-drop或者drop-create 时，Activiti在启动和初始化时，会执行相应的创建表和删除表操作。Activiti支持多种数据库， 每种数据库的创建表与删除表的语法有可能不一样，因此，需要指定databaseType属性，来告诉Activiti，目前使用了何种数据库(当然，如果设置为true而数据库中没有表的话，也需要知道使用哪种数据库)。databaseType属性支持这些值：h2、mysql、oracle、postgres、mssql 和db2。没有指定值时，databaseType为null。指定databaseType属性，目的是为了确定执行创建（或删除）<br>表的SQL脚本。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/06/%E5%88%9D%E8%AF%86Activiti%E5%B7%A5%E4%BD%9C%E6%B5%81/content12.png" class title="content12">

<h3 id="流程引擎的创建"><a href="#流程引擎的创建" class="headerlink" title="流程引擎的创建"></a>流程引擎的创建</h3><h4 id="ProcessEngineConfiguration-的-buildProcessEngine-方法"><a href="#ProcessEngineConfiguration-的-buildProcessEngine-方法" class="headerlink" title="ProcessEngineConfiguration 的 buildProcessEngine 方法"></a>ProcessEngineConfiguration 的 buildProcessEngine 方法</h4><p>使用ProcessEngineConfiguration的create方法可以创建ProcessEngineConfiguration 的实例。ProcessEngineConfiguration 中提供了一个 buildProcessEngine方法，该方法返回一个ProcessEngine实例。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/06/%E5%88%9D%E8%AF%86Activiti%E5%B7%A5%E4%BD%9C%E6%B5%81/content13.png" class title="content13">
<p>得到流程引擎的相关配置后，buildProcessEngine方法会根据这些配置，初始化流程引擎 的相关服务和对象，包括数据源、事务、拦截器和服务组件等。这个流程引擎的初始化过程, 实际上也可以被看作是一个配置检查的过程。</p>
<h4 id="ProcessEngines"><a href="#ProcessEngines" class="headerlink" title="ProcessEngines"></a>ProcessEngines</h4><p>除了 ProcessEngineConfiguration 的 buildProcessEngine 方法外，ProcessEngines 类提供了创建ProcessEngineConfiguration实例的方法。ProcessEngines是一个创建流程引擎与关闭流程引擎的工具类，所有创建(包括其他方式创建)的ProcessEngine实例均被注册到ProcessEngines 中。这里所说的注册，实际上是ProcessEngines类中维护一个Map对象，该对象的key为 ProcessEngine 实例的名称，value 为 ProcessEngine 的实例，当向 ProcessEngines 注册 ProcessEngine实例时，实际上是调用Map的put方法，将该实例缓存到Map中。<br><strong>init 与 getDefaultProcessEngine 方法</strong><br>ProcessEngines的init方法，会读取Activiti的默认配置文件，然后将创建的ProcessEngine 实例缓存到Map中。这里所说的默认配置文件，一般情况下是指ClassPath 下的activiti.cfg.xml, 如果与Spring进行了整合，则读取ClassPath下的activiti-context.xml文件。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/06/%E5%88%9D%E8%AF%86Activiti%E5%B7%A5%E4%BD%9C%E6%B5%81/content14.png" class title="content14">
<p>此处的init方法并不会返回任何ProcessEngine实例，该方法只会加载classpath下全部的 Activiti配置文件并且将创建的ProcessEngine实例保存到ProcessEngines中。如果需要得到相 应的ProcessEngine实例，可以使用getProcessEngines方法获取ProcessEngines中全部的 ProcessEngine 实例 ，getProcessEngines 返回的是一个 Map，只需要根据 ProcessEngine 的名称， 即可得到相应的ProcessEngine实例。<br>另外，ProcessEngines 提供了一个 getDefaultProcessEngine 方法，用于返回 key 为 “default” 的ProcessEngine实例，该方法会判断ProcessEngines是否进行初始化，如果没有，则会调用 init方法进行初始化。</p>
<p><strong>registerProcessEngine 和 unregister 方法</strong><br>注册和注销方法，registerProcessEngine 方法向 ProcessEngines 中注册一个 ProcessEngine 实例，unregister方法则从ProcessEngines中注销一个ProcessEngine实例。注册与注销 ProcessEngine实例，均会根据该ProcessEngine实例的名称进行操作，因为Map的key使用的 是ProcessEngine的名称。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/06/%E5%88%9D%E8%AF%86Activiti%E5%B7%A5%E4%BD%9C%E6%B5%81/content15.png" class title="content15">
<p>注意：unregister方法只是单纯地将ProcessEngine实例从Map移除，并不会调用 ProcessEngine 的 close 方法。</p>
<p><strong>retry 方法</strong><br>如果Activiti在加载配置文件时出现异常，则可以调用ProcessEngines的retry方法重新加载配置文件，重新创建ProcessEngine实例并加入到Map中。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/06/%E5%88%9D%E8%AF%86Activiti%E5%B7%A5%E4%BD%9C%E6%B5%81/content16.png" class title="content16">

<p><strong>destroy 方法</strong><br>ProcessEngines的destroy方法，顾名思义，是对其所有维护的ProcessEngine实例进行销 毁，并且在销毁时调用ProcessEngine的close方法。<br>Destory方法在执行时，会调用所有ProcessEngine实例的close方法，该方法会将异步工作执行器（AsyncExecutor）关闭，如果为流程引擎配置的数据库策略为 create-drop，则会执行数据库表的 drop 操作。</p>
<h4 id="ProcessEngine-对象"><a href="#ProcessEngine-对象" class="headerlink" title="ProcessEngine 对象"></a>ProcessEngine 对象</h4><p>在Activiti中，一个ProcessEngine实例代表一个流程引擎，ProcessEngine保存着各个服务组件的实例，根据这些服务组件，可以操作流程实例、任务、系统角色等数据。<br><strong>服务组件</strong><br>当创建流程引擎实例后，ProcessEngine中会初始化一系列服务组件，这些组件提供了大部分控制流程引擎数据的业务方法，这些组件就好像J2EE中的Service层。可以使用 ProcessEngine中的getAXYService方法得到这些组件的实例。一个ProcessEngine维护以下业务组件实例。</p>
<ul>
<li>Repositoryservice：提供一系列管理流程定义和流程部署的API。</li>
<li>Runtimeservice：在流程运行时对流程实例进行管理与控制。</li>
<li>TaskService：对流程任务进行管理，例如任务提醒、任务完成和分配任务等。</li>
<li>Identityservice：提供对流程角色数据进行管理的API,这些角色数据包括用户组、用 户以及它们之间的关系。</li>
<li>Managementservice：提供对流程引擎进行管理和维护的服务。</li>
<li>HistoryService：对流程的历史数据进行操作，包括查询、删除这些历史数据。<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/06/%E5%88%9D%E8%AF%86Activiti%E5%B7%A5%E4%BD%9C%E6%B5%81/content17.png" class title="content17"></li>
</ul>
<p>关闭流程引擎<br>ProcessEngines实例在进行销毁操作时，会调用所有ProcessEngine的close方法，还会对流程引擎进行关闭操作，这些操作包括关闭异步执行器 (AsyncExecutor)和执行数据库表删除(drop)。需要让其删除数据表，前提是要将流程引擎配置的databaseSchemaUpdate属性设置为create-drop。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/06/%E5%88%9D%E8%AF%86Activiti%E5%B7%A5%E4%BD%9C%E6%B5%81/content18.png" class title="content18">

<p>流程引擎名称<br>每个ProcessEngine实例均有自己的名称，在ProcessEngines的 Map中，会使用该名称作为Map的key值。如果不为ProcessEngine设置名称，Activiti会默认将其设置为”default”。ProcessEngine本身没有提供设置名称的方法，该方法由 ProcessEngineConfiguration提供。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/06/%E5%88%9D%E8%AF%86Activiti%E5%B7%A5%E4%BD%9C%E6%B5%81/content19.png" class title="content19">

]]></content>
      <categories>
        <category>工作流</category>
      </categories>
      <tags>
        <tag>Activiti</tag>
      </tags>
  </entry>
</search>
